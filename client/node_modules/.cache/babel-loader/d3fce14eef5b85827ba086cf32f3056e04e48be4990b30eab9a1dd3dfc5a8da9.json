{"ast":null,"code":"/*!\r\n * (C) Ionic http://ionicframework.com - MIT License\r\n */\nimport { w as win } from './index5.js';\nimport { r as raf } from './helpers.js';\nimport { a as printIonError } from './index6.js';\n\n/**\r\n * Used to update a scoped component that uses emulated slots. This fires when\r\n * content is passed into the slot or when the content inside of a slot changes.\r\n * This is not needed for components using native slots in the Shadow DOM.\r\n * @internal\r\n * @param el The host element to observe\r\n * @param slotName mutationCallback will fire when nodes on these slot(s) change\r\n * @param mutationCallback The callback to fire whenever the slotted content changes\r\n */\nconst createSlotMutationController = (el, slotName, mutationCallback) => {\n  let hostMutationObserver;\n  let slottedContentMutationObserver;\n  if (win !== undefined && 'MutationObserver' in win) {\n    const slots = Array.isArray(slotName) ? slotName : [slotName];\n    hostMutationObserver = new MutationObserver(entries => {\n      for (const entry of entries) {\n        for (const node of entry.addedNodes) {\n          /**\r\n           * Check to see if the added node\r\n           *  is our slotted content.\r\n           */\n          if (node.nodeType === Node.ELEMENT_NODE && slots.includes(node.slot)) {\n            /**\r\n             * If so, we want to watch the slotted\r\n             * content itself for changes. This lets us\r\n             * detect when content inside of the slot changes.\r\n             */\n            mutationCallback();\n            /**\r\n             * Adding the listener in an raf\r\n             * waits until Stencil moves the slotted element\r\n             * into the correct place in the event that\r\n             * slotted content is being added.\r\n             */\n            raf(() => watchForSlotChange(node));\n            return;\n          }\n        }\n      }\n    });\n    hostMutationObserver.observe(el, {\n      childList: true\n    });\n  }\n  /**\r\n   * Listen for changes inside of the slotted content.\r\n   * We can listen for subtree changes here to be\r\n   * informed of text within the slotted content\r\n   * changing. Doing this on the host is possible\r\n   * but it is much more expensive to do because\r\n   * it also listens for changes to the internals\r\n   * of the component.\r\n   */\n  const watchForSlotChange = slottedEl => {\n    var _a;\n    if (slottedContentMutationObserver) {\n      slottedContentMutationObserver.disconnect();\n      slottedContentMutationObserver = undefined;\n    }\n    slottedContentMutationObserver = new MutationObserver(entries => {\n      mutationCallback();\n      for (const entry of entries) {\n        for (const node of entry.removedNodes) {\n          /**\r\n           * If the element was removed then we\r\n           * need to destroy the MutationObserver\r\n           * so the element can be garbage collected.\r\n           */\n          if (node.nodeType === Node.ELEMENT_NODE && node.slot === slotName) {\n            destroySlottedContentObserver();\n          }\n        }\n      }\n    });\n    /**\r\n     * Listen for changes inside of the element\r\n     * as well as anything deep in the tree.\r\n     * We listen on the parentElement so that we can\r\n     * detect when slotted element itself is removed.\r\n     */\n    slottedContentMutationObserver.observe((_a = slottedEl.parentElement) !== null && _a !== void 0 ? _a : slottedEl, {\n      subtree: true,\n      childList: true\n    });\n  };\n  const destroy = () => {\n    if (hostMutationObserver) {\n      hostMutationObserver.disconnect();\n      hostMutationObserver = undefined;\n    }\n    destroySlottedContentObserver();\n  };\n  const destroySlottedContentObserver = () => {\n    if (slottedContentMutationObserver) {\n      slottedContentMutationObserver.disconnect();\n      slottedContentMutationObserver = undefined;\n    }\n  };\n  return {\n    destroy\n  };\n};\nconst getCounterText = (value, maxLength, counterFormatter) => {\n  const valueLength = value == null ? 0 : value.toString().length;\n  const defaultCounterText = defaultCounterFormatter(valueLength, maxLength);\n  /**\r\n   * If developers did not pass a custom formatter,\r\n   * use the default one.\r\n   */\n  if (counterFormatter === undefined) {\n    return defaultCounterText;\n  }\n  /**\r\n   * Otherwise, try to use the custom formatter\r\n   * and fallback to the default formatter if\r\n   * there was an error.\r\n   */\n  try {\n    return counterFormatter(valueLength, maxLength);\n  } catch (e) {\n    printIonError('Exception in provided `counterFormatter`.', e);\n    return defaultCounterText;\n  }\n};\nconst defaultCounterFormatter = (length, maxlength) => {\n  return `${length} / ${maxlength}`;\n};\nexport { createSlotMutationController as c, getCounterText as g };","map":{"version":3,"names":["w","win","r","raf","a","printIonError","createSlotMutationController","el","slotName","mutationCallback","hostMutationObserver","slottedContentMutationObserver","undefined","slots","Array","isArray","MutationObserver","entries","entry","node","addedNodes","nodeType","Node","ELEMENT_NODE","includes","slot","watchForSlotChange","observe","childList","slottedEl","_a","disconnect","removedNodes","destroySlottedContentObserver","parentElement","subtree","destroy","getCounterText","value","maxLength","counterFormatter","valueLength","toString","length","defaultCounterText","defaultCounterFormatter","e","maxlength","c","g"],"sources":["E:/Online-Voting-Portal/client/node_modules/@ionic/core/components/input.utils.js"],"sourcesContent":["/*!\r\n * (C) Ionic http://ionicframework.com - MIT License\r\n */\r\nimport { w as win } from './index5.js';\r\nimport { r as raf } from './helpers.js';\r\nimport { a as printIonError } from './index6.js';\r\n\r\n/**\r\n * Used to update a scoped component that uses emulated slots. This fires when\r\n * content is passed into the slot or when the content inside of a slot changes.\r\n * This is not needed for components using native slots in the Shadow DOM.\r\n * @internal\r\n * @param el The host element to observe\r\n * @param slotName mutationCallback will fire when nodes on these slot(s) change\r\n * @param mutationCallback The callback to fire whenever the slotted content changes\r\n */\r\nconst createSlotMutationController = (el, slotName, mutationCallback) => {\r\n    let hostMutationObserver;\r\n    let slottedContentMutationObserver;\r\n    if (win !== undefined && 'MutationObserver' in win) {\r\n        const slots = Array.isArray(slotName) ? slotName : [slotName];\r\n        hostMutationObserver = new MutationObserver((entries) => {\r\n            for (const entry of entries) {\r\n                for (const node of entry.addedNodes) {\r\n                    /**\r\n                     * Check to see if the added node\r\n                     *  is our slotted content.\r\n                     */\r\n                    if (node.nodeType === Node.ELEMENT_NODE && slots.includes(node.slot)) {\r\n                        /**\r\n                         * If so, we want to watch the slotted\r\n                         * content itself for changes. This lets us\r\n                         * detect when content inside of the slot changes.\r\n                         */\r\n                        mutationCallback();\r\n                        /**\r\n                         * Adding the listener in an raf\r\n                         * waits until Stencil moves the slotted element\r\n                         * into the correct place in the event that\r\n                         * slotted content is being added.\r\n                         */\r\n                        raf(() => watchForSlotChange(node));\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        hostMutationObserver.observe(el, {\r\n            childList: true,\r\n        });\r\n    }\r\n    /**\r\n     * Listen for changes inside of the slotted content.\r\n     * We can listen for subtree changes here to be\r\n     * informed of text within the slotted content\r\n     * changing. Doing this on the host is possible\r\n     * but it is much more expensive to do because\r\n     * it also listens for changes to the internals\r\n     * of the component.\r\n     */\r\n    const watchForSlotChange = (slottedEl) => {\r\n        var _a;\r\n        if (slottedContentMutationObserver) {\r\n            slottedContentMutationObserver.disconnect();\r\n            slottedContentMutationObserver = undefined;\r\n        }\r\n        slottedContentMutationObserver = new MutationObserver((entries) => {\r\n            mutationCallback();\r\n            for (const entry of entries) {\r\n                for (const node of entry.removedNodes) {\r\n                    /**\r\n                     * If the element was removed then we\r\n                     * need to destroy the MutationObserver\r\n                     * so the element can be garbage collected.\r\n                     */\r\n                    if (node.nodeType === Node.ELEMENT_NODE && node.slot === slotName) {\r\n                        destroySlottedContentObserver();\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        /**\r\n         * Listen for changes inside of the element\r\n         * as well as anything deep in the tree.\r\n         * We listen on the parentElement so that we can\r\n         * detect when slotted element itself is removed.\r\n         */\r\n        slottedContentMutationObserver.observe((_a = slottedEl.parentElement) !== null && _a !== void 0 ? _a : slottedEl, { subtree: true, childList: true });\r\n    };\r\n    const destroy = () => {\r\n        if (hostMutationObserver) {\r\n            hostMutationObserver.disconnect();\r\n            hostMutationObserver = undefined;\r\n        }\r\n        destroySlottedContentObserver();\r\n    };\r\n    const destroySlottedContentObserver = () => {\r\n        if (slottedContentMutationObserver) {\r\n            slottedContentMutationObserver.disconnect();\r\n            slottedContentMutationObserver = undefined;\r\n        }\r\n    };\r\n    return {\r\n        destroy,\r\n    };\r\n};\r\n\r\nconst getCounterText = (value, maxLength, counterFormatter) => {\r\n    const valueLength = value == null ? 0 : value.toString().length;\r\n    const defaultCounterText = defaultCounterFormatter(valueLength, maxLength);\r\n    /**\r\n     * If developers did not pass a custom formatter,\r\n     * use the default one.\r\n     */\r\n    if (counterFormatter === undefined) {\r\n        return defaultCounterText;\r\n    }\r\n    /**\r\n     * Otherwise, try to use the custom formatter\r\n     * and fallback to the default formatter if\r\n     * there was an error.\r\n     */\r\n    try {\r\n        return counterFormatter(valueLength, maxLength);\r\n    }\r\n    catch (e) {\r\n        printIonError('Exception in provided `counterFormatter`.', e);\r\n        return defaultCounterText;\r\n    }\r\n};\r\nconst defaultCounterFormatter = (length, maxlength) => {\r\n    return `${length} / ${maxlength}`;\r\n};\r\n\r\nexport { createSlotMutationController as c, getCounterText as g };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}