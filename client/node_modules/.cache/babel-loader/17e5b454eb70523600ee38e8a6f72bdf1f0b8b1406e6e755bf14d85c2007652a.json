{"ast":null,"code":"/*!\r\n * (C) Ionic http://ionicframework.com - MIT License\r\n */\nimport { w as win } from './index5.js';\nimport { c as config } from './ionic-global.js';\n\n/**\r\n * CloseWatcher is a newer API that lets\r\n * use detect the hardware back button event\r\n * in a web browser: https://caniuse.com/?search=closewatcher\r\n * However, not every browser supports it yet.\r\n *\r\n * This needs to be a function so that we can\r\n * check the config once it has been set.\r\n * Otherwise, this code would be evaluated the\r\n * moment this file is evaluated which could be\r\n * before the config is set.\r\n */\nconst shouldUseCloseWatcher = () => config.get('experimentalCloseWatcher', false) && win !== undefined && 'CloseWatcher' in win;\n/**\r\n * When hardwareBackButton: false in config,\r\n * we need to make sure we also block the default\r\n * webview behavior. If we don't then it will be\r\n * possible for users to navigate backward while\r\n * an overlay is still open. Additionally, it will\r\n * give the appearance that the hardwareBackButton\r\n * config is not working as the page transition\r\n * will still happen.\r\n */\nconst blockHardwareBackButton = () => {\n  document.addEventListener('backbutton', () => {}); // eslint-disable-line\n};\nconst startHardwareBackButton = () => {\n  const doc = document;\n  let busy = false;\n  const backButtonCallback = () => {\n    if (busy) {\n      return;\n    }\n    let index = 0;\n    let handlers = [];\n    const ev = new CustomEvent('ionBackButton', {\n      bubbles: false,\n      detail: {\n        register(priority, handler) {\n          handlers.push({\n            priority,\n            handler,\n            id: index++\n          });\n        }\n      }\n    });\n    doc.dispatchEvent(ev);\n    const executeAction = async handlerRegister => {\n      try {\n        if (handlerRegister === null || handlerRegister === void 0 ? void 0 : handlerRegister.handler) {\n          const result = handlerRegister.handler(processHandlers);\n          if (result != null) {\n            await result;\n          }\n        }\n      } catch (e) {\n        console.error(e);\n      }\n    };\n    const processHandlers = () => {\n      if (handlers.length > 0) {\n        let selectedHandler = {\n          priority: Number.MIN_SAFE_INTEGER,\n          handler: () => undefined,\n          id: -1\n        };\n        handlers.forEach(handler => {\n          if (handler.priority >= selectedHandler.priority) {\n            selectedHandler = handler;\n          }\n        });\n        busy = true;\n        handlers = handlers.filter(handler => handler.id !== selectedHandler.id);\n        executeAction(selectedHandler).then(() => busy = false);\n      }\n    };\n    processHandlers();\n  };\n  /**\r\n   * If the CloseWatcher is defined then\r\n   * we don't want to also listen for the native\r\n   * backbutton event otherwise we may get duplicate\r\n   * events firing.\r\n   */\n  if (shouldUseCloseWatcher()) {\n    let watcher;\n    const configureWatcher = () => {\n      watcher === null || watcher === void 0 ? void 0 : watcher.destroy();\n      watcher = new win.CloseWatcher();\n      /**\r\n       * Once a close request happens\r\n       * the watcher gets destroyed.\r\n       * As a result, we need to re-configure\r\n       * the watcher so we can respond to other\r\n       * close requests.\r\n       */\n      watcher.onclose = () => {\n        backButtonCallback();\n        configureWatcher();\n      };\n    };\n    configureWatcher();\n  } else {\n    doc.addEventListener('backbutton', backButtonCallback);\n  }\n};\nconst OVERLAY_BACK_BUTTON_PRIORITY = 100;\nconst MENU_BACK_BUTTON_PRIORITY = 99; // 1 less than overlay priority since menu is displayed behind overlays\n\nexport { MENU_BACK_BUTTON_PRIORITY, OVERLAY_BACK_BUTTON_PRIORITY, blockHardwareBackButton, shouldUseCloseWatcher, startHardwareBackButton };","map":{"version":3,"names":["w","win","c","config","shouldUseCloseWatcher","get","undefined","blockHardwareBackButton","document","addEventListener","startHardwareBackButton","doc","busy","backButtonCallback","index","handlers","ev","CustomEvent","bubbles","detail","register","priority","handler","push","id","dispatchEvent","executeAction","handlerRegister","result","processHandlers","e","console","error","length","selectedHandler","Number","MIN_SAFE_INTEGER","forEach","filter","then","watcher","configureWatcher","destroy","CloseWatcher","onclose","OVERLAY_BACK_BUTTON_PRIORITY","MENU_BACK_BUTTON_PRIORITY"],"sources":["E:/Online-Voting-Portal/client/node_modules/@ionic/core/components/hardware-back-button.js"],"sourcesContent":["/*!\r\n * (C) Ionic http://ionicframework.com - MIT License\r\n */\r\nimport { w as win } from './index5.js';\r\nimport { c as config } from './ionic-global.js';\r\n\r\n/**\r\n * CloseWatcher is a newer API that lets\r\n * use detect the hardware back button event\r\n * in a web browser: https://caniuse.com/?search=closewatcher\r\n * However, not every browser supports it yet.\r\n *\r\n * This needs to be a function so that we can\r\n * check the config once it has been set.\r\n * Otherwise, this code would be evaluated the\r\n * moment this file is evaluated which could be\r\n * before the config is set.\r\n */\r\nconst shouldUseCloseWatcher = () => config.get('experimentalCloseWatcher', false) && win !== undefined && 'CloseWatcher' in win;\r\n/**\r\n * When hardwareBackButton: false in config,\r\n * we need to make sure we also block the default\r\n * webview behavior. If we don't then it will be\r\n * possible for users to navigate backward while\r\n * an overlay is still open. Additionally, it will\r\n * give the appearance that the hardwareBackButton\r\n * config is not working as the page transition\r\n * will still happen.\r\n */\r\nconst blockHardwareBackButton = () => {\r\n    document.addEventListener('backbutton', () => { }); // eslint-disable-line\r\n};\r\nconst startHardwareBackButton = () => {\r\n    const doc = document;\r\n    let busy = false;\r\n    const backButtonCallback = () => {\r\n        if (busy) {\r\n            return;\r\n        }\r\n        let index = 0;\r\n        let handlers = [];\r\n        const ev = new CustomEvent('ionBackButton', {\r\n            bubbles: false,\r\n            detail: {\r\n                register(priority, handler) {\r\n                    handlers.push({ priority, handler, id: index++ });\r\n                },\r\n            },\r\n        });\r\n        doc.dispatchEvent(ev);\r\n        const executeAction = async (handlerRegister) => {\r\n            try {\r\n                if (handlerRegister === null || handlerRegister === void 0 ? void 0 : handlerRegister.handler) {\r\n                    const result = handlerRegister.handler(processHandlers);\r\n                    if (result != null) {\r\n                        await result;\r\n                    }\r\n                }\r\n            }\r\n            catch (e) {\r\n                console.error(e);\r\n            }\r\n        };\r\n        const processHandlers = () => {\r\n            if (handlers.length > 0) {\r\n                let selectedHandler = {\r\n                    priority: Number.MIN_SAFE_INTEGER,\r\n                    handler: () => undefined,\r\n                    id: -1,\r\n                };\r\n                handlers.forEach((handler) => {\r\n                    if (handler.priority >= selectedHandler.priority) {\r\n                        selectedHandler = handler;\r\n                    }\r\n                });\r\n                busy = true;\r\n                handlers = handlers.filter((handler) => handler.id !== selectedHandler.id);\r\n                executeAction(selectedHandler).then(() => (busy = false));\r\n            }\r\n        };\r\n        processHandlers();\r\n    };\r\n    /**\r\n     * If the CloseWatcher is defined then\r\n     * we don't want to also listen for the native\r\n     * backbutton event otherwise we may get duplicate\r\n     * events firing.\r\n     */\r\n    if (shouldUseCloseWatcher()) {\r\n        let watcher;\r\n        const configureWatcher = () => {\r\n            watcher === null || watcher === void 0 ? void 0 : watcher.destroy();\r\n            watcher = new win.CloseWatcher();\r\n            /**\r\n             * Once a close request happens\r\n             * the watcher gets destroyed.\r\n             * As a result, we need to re-configure\r\n             * the watcher so we can respond to other\r\n             * close requests.\r\n             */\r\n            watcher.onclose = () => {\r\n                backButtonCallback();\r\n                configureWatcher();\r\n            };\r\n        };\r\n        configureWatcher();\r\n    }\r\n    else {\r\n        doc.addEventListener('backbutton', backButtonCallback);\r\n    }\r\n};\r\nconst OVERLAY_BACK_BUTTON_PRIORITY = 100;\r\nconst MENU_BACK_BUTTON_PRIORITY = 99; // 1 less than overlay priority since menu is displayed behind overlays\r\n\r\nexport { MENU_BACK_BUTTON_PRIORITY, OVERLAY_BACK_BUTTON_PRIORITY, blockHardwareBackButton, shouldUseCloseWatcher, startHardwareBackButton };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}