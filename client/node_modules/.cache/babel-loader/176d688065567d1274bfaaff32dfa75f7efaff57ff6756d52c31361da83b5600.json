{"ast":null,"code":"/*!\r\n * (C) Ionic http://ionicframework.com - MIT License\r\n */\nimport { readTask, writeTask, proxyCustomElement, HTMLElement, h, Host } from '@stencil/core/internal/client';\nimport { g as getScrollElement, f as findIonContent, p as printIonContentErrorMsg } from './index8.js';\nimport { m as clamp, i as inheritAriaAttributes } from './helpers.js';\nimport { h as hostContext } from './theme.js';\nimport { b as getIonMode } from './ionic-global.js';\nconst TRANSITION = 'all 0.2s ease-in-out';\nconst cloneElement = tagName => {\n  const getCachedEl = document.querySelector(`${tagName}.ion-cloned-element`);\n  if (getCachedEl !== null) {\n    return getCachedEl;\n  }\n  const clonedEl = document.createElement(tagName);\n  clonedEl.classList.add('ion-cloned-element');\n  clonedEl.style.setProperty('display', 'none');\n  document.body.appendChild(clonedEl);\n  return clonedEl;\n};\nconst createHeaderIndex = headerEl => {\n  if (!headerEl) {\n    return;\n  }\n  const toolbars = headerEl.querySelectorAll('ion-toolbar');\n  return {\n    el: headerEl,\n    toolbars: Array.from(toolbars).map(toolbar => {\n      const ionTitleEl = toolbar.querySelector('ion-title');\n      return {\n        el: toolbar,\n        background: toolbar.shadowRoot.querySelector('.toolbar-background'),\n        ionTitleEl,\n        innerTitleEl: ionTitleEl ? ionTitleEl.shadowRoot.querySelector('.toolbar-title') : null,\n        ionButtonsEl: Array.from(toolbar.querySelectorAll('ion-buttons'))\n      };\n    })\n  };\n};\nconst handleContentScroll = (scrollEl, scrollHeaderIndex, contentEl) => {\n  readTask(() => {\n    const scrollTop = scrollEl.scrollTop;\n    const scale = clamp(1, 1 + -scrollTop / 500, 1.1);\n    // Native refresher should not cause titles to scale\n    const nativeRefresher = contentEl.querySelector('ion-refresher.refresher-native');\n    if (nativeRefresher === null) {\n      writeTask(() => {\n        scaleLargeTitles(scrollHeaderIndex.toolbars, scale);\n      });\n    }\n  });\n};\nconst setToolbarBackgroundOpacity = (headerEl, opacity) => {\n  /**\r\n   * Fading in the backdrop opacity\r\n   * should happen after the large title\r\n   * has collapsed, so it is handled\r\n   * by handleHeaderFade()\r\n   */\n  if (headerEl.collapse === 'fade') {\n    return;\n  }\n  if (opacity === undefined) {\n    headerEl.style.removeProperty('--opacity-scale');\n  } else {\n    headerEl.style.setProperty('--opacity-scale', opacity.toString());\n  }\n};\nconst handleToolbarBorderIntersection = (ev, mainHeaderIndex, scrollTop) => {\n  if (!ev[0].isIntersecting) {\n    return;\n  }\n  /**\r\n   * There is a bug in Safari where overflow scrolling on a non-body element\r\n   * does not always reset the scrollTop position to 0 when letting go. It will\r\n   * set to 1 once the rubber band effect has ended. This causes the background to\r\n   * appear slightly on certain app setups.\r\n   *\r\n   * Additionally, we check if user is rubber banding (scrolling is negative)\r\n   * as this can mean they are using pull to refresh. Once the refresher starts,\r\n   * the content is transformed which can cause the intersection observer to erroneously\r\n   * fire here as well.\r\n   */\n  const scale = ev[0].intersectionRatio > 0.9 || scrollTop <= 0 ? 0 : (1 - ev[0].intersectionRatio) * 100 / 75;\n  setToolbarBackgroundOpacity(mainHeaderIndex.el, scale === 1 ? undefined : scale);\n};\n/**\r\n * If toolbars are intersecting, hide the scrollable toolbar content\r\n * and show the primary toolbar content. If the toolbars are not intersecting,\r\n * hide the primary toolbar content and show the scrollable toolbar content\r\n */\nconst handleToolbarIntersection = (ev,\n// TODO(FW-2832): type (IntersectionObserverEntry[] triggers errors which should be sorted)\nmainHeaderIndex, scrollHeaderIndex, scrollEl) => {\n  writeTask(() => {\n    const scrollTop = scrollEl.scrollTop;\n    handleToolbarBorderIntersection(ev, mainHeaderIndex, scrollTop);\n    const event = ev[0];\n    const intersection = event.intersectionRect;\n    const intersectionArea = intersection.width * intersection.height;\n    const rootArea = event.rootBounds.width * event.rootBounds.height;\n    const isPageHidden = intersectionArea === 0 && rootArea === 0;\n    const leftDiff = Math.abs(intersection.left - event.boundingClientRect.left);\n    const rightDiff = Math.abs(intersection.right - event.boundingClientRect.right);\n    const isPageTransitioning = intersectionArea > 0 && (leftDiff >= 5 || rightDiff >= 5);\n    if (isPageHidden || isPageTransitioning) {\n      return;\n    }\n    if (event.isIntersecting) {\n      setHeaderActive(mainHeaderIndex, false);\n      setHeaderActive(scrollHeaderIndex);\n    } else {\n      /**\r\n       * There is a bug with IntersectionObserver on Safari\r\n       * where `event.isIntersecting === false` when cancelling\r\n       * a swipe to go back gesture. Checking the intersection\r\n       * x, y, width, and height provides a workaround. This bug\r\n       * does not happen when using Safari + Web Animations,\r\n       * only Safari + CSS Animations.\r\n       */\n      const hasValidIntersection = intersection.x === 0 && intersection.y === 0 || intersection.width !== 0 && intersection.height !== 0;\n      if (hasValidIntersection && scrollTop > 0) {\n        setHeaderActive(mainHeaderIndex);\n        setHeaderActive(scrollHeaderIndex, false);\n        setToolbarBackgroundOpacity(mainHeaderIndex.el);\n      }\n    }\n  });\n};\nconst setHeaderActive = (headerIndex, active = true) => {\n  const headerEl = headerIndex.el;\n  if (active) {\n    headerEl.classList.remove('header-collapse-condense-inactive');\n    headerEl.removeAttribute('aria-hidden');\n  } else {\n    headerEl.classList.add('header-collapse-condense-inactive');\n    headerEl.setAttribute('aria-hidden', 'true');\n  }\n};\nconst scaleLargeTitles = (toolbars = [], scale = 1, transition = false) => {\n  toolbars.forEach(toolbar => {\n    const ionTitle = toolbar.ionTitleEl;\n    const titleDiv = toolbar.innerTitleEl;\n    if (!ionTitle || ionTitle.size !== 'large') {\n      return;\n    }\n    titleDiv.style.transition = transition ? TRANSITION : '';\n    titleDiv.style.transform = `scale3d(${scale}, ${scale}, 1)`;\n  });\n};\nconst handleHeaderFade = (scrollEl, baseEl, condenseHeader) => {\n  readTask(() => {\n    const scrollTop = scrollEl.scrollTop;\n    const baseElHeight = baseEl.clientHeight;\n    const fadeStart = condenseHeader ? condenseHeader.clientHeight : 0;\n    /**\r\n     * If we are using fade header with a condense\r\n     * header, then the toolbar backgrounds should\r\n     * not begin to fade in until the condense\r\n     * header has fully collapsed.\r\n     *\r\n     * Additionally, the main content should not\r\n     * overflow out of the container until the\r\n     * condense header has fully collapsed. When\r\n     * using just the condense header the content\r\n     * should overflow out of the container.\r\n     */\n    if (condenseHeader !== null && scrollTop < fadeStart) {\n      baseEl.style.setProperty('--opacity-scale', '0');\n      scrollEl.style.setProperty('clip-path', `inset(${baseElHeight}px 0px 0px 0px)`);\n      return;\n    }\n    const distanceToStart = scrollTop - fadeStart;\n    const fadeDuration = 10;\n    const scale = clamp(0, distanceToStart / fadeDuration, 1);\n    writeTask(() => {\n      scrollEl.style.removeProperty('clip-path');\n      baseEl.style.setProperty('--opacity-scale', scale.toString());\n    });\n  });\n};\nconst headerIosCss = \"ion-header{display:block;position:relative;-ms-flex-order:-1;order:-1;width:100%;z-index:10}ion-header ion-toolbar:first-of-type{padding-top:var(--ion-safe-area-top, 0)}.header-ios ion-toolbar:last-of-type{--border-width:0 0 0.55px}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){.header-background{left:0;right:0;top:0;bottom:0;position:absolute;-webkit-backdrop-filter:saturate(180%) blur(20px);backdrop-filter:saturate(180%) blur(20px)}.header-translucent-ios ion-toolbar{--opacity:.8}.header-collapse-condense-inactive .header-background{-webkit-backdrop-filter:blur(20px);backdrop-filter:blur(20px)}}.header-ios.ion-no-border ion-toolbar:last-of-type{--border-width:0}.header-collapse-fade ion-toolbar{--opacity-scale:inherit}.header-collapse-condense{z-index:9}.header-collapse-condense ion-toolbar{position:-webkit-sticky;position:sticky;top:0}.header-collapse-condense ion-toolbar:first-of-type{padding-top:0px;z-index:1}.header-collapse-condense ion-toolbar{--background:var(--ion-background-color, #fff);z-index:0}.header-collapse-condense ion-toolbar:last-of-type{--border-width:0px}.header-collapse-condense ion-toolbar ion-searchbar{padding-top:0px;padding-bottom:13px}.header-collapse-main{--opacity-scale:1}.header-collapse-main ion-toolbar{--opacity-scale:inherit}.header-collapse-main ion-toolbar.in-toolbar ion-title,.header-collapse-main ion-toolbar.in-toolbar ion-buttons{-webkit-transition:all 0.2s ease-in-out;transition:all 0.2s ease-in-out}.header-collapse-condense-inactive:not(.header-collapse-condense) ion-toolbar.in-toolbar ion-title,.header-collapse-condense-inactive:not(.header-collapse-condense) ion-toolbar.in-toolbar ion-buttons.buttons-collapse{opacity:0;pointer-events:none}.header-collapse-condense-inactive.header-collapse-condense ion-toolbar.in-toolbar ion-title,.header-collapse-condense-inactive.header-collapse-condense ion-toolbar.in-toolbar ion-buttons.buttons-collapse{visibility:hidden}ion-header.header-ios:not(.header-collapse-main):has(~ion-content ion-header.header-ios[collapse=condense],~ion-content ion-header.header-ios.header-collapse-condense){opacity:0}\";\nconst IonHeaderIosStyle0 = headerIosCss;\nconst headerMdCss = \"ion-header{display:block;position:relative;-ms-flex-order:-1;order:-1;width:100%;z-index:10}ion-header ion-toolbar:first-of-type{padding-top:var(--ion-safe-area-top, 0)}.header-md{-webkit-box-shadow:0 2px 4px -1px rgba(0, 0, 0, 0.2), 0 4px 5px 0 rgba(0, 0, 0, 0.14), 0 1px 10px 0 rgba(0, 0, 0, 0.12);box-shadow:0 2px 4px -1px rgba(0, 0, 0, 0.2), 0 4px 5px 0 rgba(0, 0, 0, 0.14), 0 1px 10px 0 rgba(0, 0, 0, 0.12)}.header-collapse-condense{display:none}.header-md.ion-no-border{-webkit-box-shadow:none;box-shadow:none}\";\nconst IonHeaderMdStyle0 = headerMdCss;\nconst Header = /*@__PURE__*/proxyCustomElement(class Header extends HTMLElement {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.inheritedAttributes = {};\n    this.setupFadeHeader = async (contentEl, condenseHeader) => {\n      const scrollEl = this.scrollEl = await getScrollElement(contentEl);\n      /**\r\n       * Handle fading of toolbars on scroll\r\n       */\n      this.contentScrollCallback = () => {\n        handleHeaderFade(this.scrollEl, this.el, condenseHeader);\n      };\n      scrollEl.addEventListener('scroll', this.contentScrollCallback);\n      handleHeaderFade(this.scrollEl, this.el, condenseHeader);\n    };\n    this.collapse = undefined;\n    this.translucent = false;\n  }\n  componentWillLoad() {\n    this.inheritedAttributes = inheritAriaAttributes(this.el);\n  }\n  componentDidLoad() {\n    this.checkCollapsibleHeader();\n  }\n  componentDidUpdate() {\n    this.checkCollapsibleHeader();\n  }\n  disconnectedCallback() {\n    this.destroyCollapsibleHeader();\n  }\n  async checkCollapsibleHeader() {\n    const mode = getIonMode(this);\n    if (mode !== 'ios') {\n      return;\n    }\n    const {\n      collapse\n    } = this;\n    const hasCondense = collapse === 'condense';\n    const hasFade = collapse === 'fade';\n    this.destroyCollapsibleHeader();\n    if (hasCondense) {\n      const pageEl = this.el.closest('ion-app,ion-page,.ion-page,page-inner');\n      const contentEl = pageEl ? findIonContent(pageEl) : null;\n      // Cloned elements are always needed in iOS transition\n      writeTask(() => {\n        const title = cloneElement('ion-title');\n        title.size = 'large';\n        cloneElement('ion-back-button');\n      });\n      await this.setupCondenseHeader(contentEl, pageEl);\n    } else if (hasFade) {\n      const pageEl = this.el.closest('ion-app,ion-page,.ion-page,page-inner');\n      const contentEl = pageEl ? findIonContent(pageEl) : null;\n      if (!contentEl) {\n        printIonContentErrorMsg(this.el);\n        return;\n      }\n      const condenseHeader = contentEl.querySelector('ion-header[collapse=\"condense\"]');\n      await this.setupFadeHeader(contentEl, condenseHeader);\n    }\n  }\n  destroyCollapsibleHeader() {\n    if (this.intersectionObserver) {\n      this.intersectionObserver.disconnect();\n      this.intersectionObserver = undefined;\n    }\n    if (this.scrollEl && this.contentScrollCallback) {\n      this.scrollEl.removeEventListener('scroll', this.contentScrollCallback);\n      this.contentScrollCallback = undefined;\n    }\n    if (this.collapsibleMainHeader) {\n      this.collapsibleMainHeader.classList.remove('header-collapse-main');\n      this.collapsibleMainHeader = undefined;\n    }\n  }\n  async setupCondenseHeader(contentEl, pageEl) {\n    if (!contentEl || !pageEl) {\n      printIonContentErrorMsg(this.el);\n      return;\n    }\n    if (typeof IntersectionObserver === 'undefined') {\n      return;\n    }\n    this.scrollEl = await getScrollElement(contentEl);\n    const headers = pageEl.querySelectorAll('ion-header');\n    this.collapsibleMainHeader = Array.from(headers).find(header => header.collapse !== 'condense');\n    if (!this.collapsibleMainHeader) {\n      return;\n    }\n    const mainHeaderIndex = createHeaderIndex(this.collapsibleMainHeader);\n    const scrollHeaderIndex = createHeaderIndex(this.el);\n    if (!mainHeaderIndex || !scrollHeaderIndex) {\n      return;\n    }\n    setHeaderActive(mainHeaderIndex, false);\n    setToolbarBackgroundOpacity(mainHeaderIndex.el, 0);\n    /**\r\n     * Handle interaction between toolbar collapse and\r\n     * showing/hiding content in the primary ion-header\r\n     * as well as progressively showing/hiding the main header\r\n     * border as the top-most toolbar collapses or expands.\r\n     */\n    const toolbarIntersection = ev => {\n      handleToolbarIntersection(ev, mainHeaderIndex, scrollHeaderIndex, this.scrollEl);\n    };\n    this.intersectionObserver = new IntersectionObserver(toolbarIntersection, {\n      root: contentEl,\n      threshold: [0.25, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]\n    });\n    this.intersectionObserver.observe(scrollHeaderIndex.toolbars[scrollHeaderIndex.toolbars.length - 1].el);\n    /**\r\n     * Handle scaling of large iOS titles and\r\n     * showing/hiding border on last toolbar\r\n     * in primary header\r\n     */\n    this.contentScrollCallback = () => {\n      handleContentScroll(this.scrollEl, scrollHeaderIndex, contentEl);\n    };\n    this.scrollEl.addEventListener('scroll', this.contentScrollCallback);\n    writeTask(() => {\n      if (this.collapsibleMainHeader !== undefined) {\n        this.collapsibleMainHeader.classList.add('header-collapse-main');\n      }\n    });\n  }\n  render() {\n    const {\n      translucent,\n      inheritedAttributes\n    } = this;\n    const mode = getIonMode(this);\n    const collapse = this.collapse || 'none';\n    // banner role must be at top level, so remove role if inside a menu\n    const roleType = hostContext('ion-menu', this.el) ? 'none' : 'banner';\n    return h(Host, Object.assign({\n      key: 'be4386a218c20dc4c18320dbbcfb25574d13d27e',\n      role: roleType,\n      class: {\n        [mode]: true,\n        // Used internally for styling\n        [`header-${mode}`]: true,\n        [`header-translucent`]: this.translucent,\n        [`header-collapse-${collapse}`]: true,\n        [`header-translucent-${mode}`]: this.translucent\n      }\n    }, inheritedAttributes), mode === 'ios' && translucent && h(\"div\", {\n      class: \"header-background\"\n    }), h(\"slot\", {\n      key: '74c401fb331aeb40c733605fd580949ad53989b8'\n    }));\n  }\n  get el() {\n    return this;\n  }\n  static get style() {\n    return {\n      ios: IonHeaderIosStyle0,\n      md: IonHeaderMdStyle0\n    };\n  }\n}, [36, \"ion-header\", {\n  \"collapse\": [1],\n  \"translucent\": [4]\n}]);\nfunction defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-header\"];\n  components.forEach(tagName => {\n    switch (tagName) {\n      case \"ion-header\":\n        if (!customElements.get(tagName)) {\n          customElements.define(tagName, Header);\n        }\n        break;\n    }\n  });\n}\nconst IonHeader = Header;\nconst defineCustomElement = defineCustomElement$1;\nexport { IonHeader, defineCustomElement };","map":{"version":3,"names":["readTask","writeTask","proxyCustomElement","HTMLElement","h","Host","g","getScrollElement","f","findIonContent","p","printIonContentErrorMsg","m","clamp","i","inheritAriaAttributes","hostContext","b","getIonMode","TRANSITION","cloneElement","tagName","getCachedEl","document","querySelector","clonedEl","createElement","classList","add","style","setProperty","body","appendChild","createHeaderIndex","headerEl","toolbars","querySelectorAll","el","Array","from","map","toolbar","ionTitleEl","background","shadowRoot","innerTitleEl","ionButtonsEl","handleContentScroll","scrollEl","scrollHeaderIndex","contentEl","scrollTop","scale","nativeRefresher","scaleLargeTitles","setToolbarBackgroundOpacity","opacity","collapse","undefined","removeProperty","toString","handleToolbarBorderIntersection","ev","mainHeaderIndex","isIntersecting","intersectionRatio","handleToolbarIntersection","event","intersection","intersectionRect","intersectionArea","width","height","rootArea","rootBounds","isPageHidden","leftDiff","Math","abs","left","boundingClientRect","rightDiff","right","isPageTransitioning","setHeaderActive","hasValidIntersection","x","y","headerIndex","active","remove","removeAttribute","setAttribute","transition","forEach","ionTitle","titleDiv","size","transform","handleHeaderFade","baseEl","condenseHeader","baseElHeight","clientHeight","fadeStart","distanceToStart","fadeDuration","headerIosCss","IonHeaderIosStyle0","headerMdCss","IonHeaderMdStyle0","Header","constructor","__registerHost","inheritedAttributes","setupFadeHeader","contentScrollCallback","addEventListener","translucent","componentWillLoad","componentDidLoad","checkCollapsibleHeader","componentDidUpdate","disconnectedCallback","destroyCollapsibleHeader","mode","hasCondense","hasFade","pageEl","closest","title","setupCondenseHeader","intersectionObserver","disconnect","removeEventListener","collapsibleMainHeader","IntersectionObserver","headers","find","header","toolbarIntersection","root","threshold","observe","length","render","roleType","Object","assign","key","role","class","ios","md","defineCustomElement$1","customElements","components","get","define","IonHeader","defineCustomElement"],"sources":["E:/Online-Voting-Portal/client/node_modules/@ionic/core/components/ion-header.js"],"sourcesContent":["/*!\r\n * (C) Ionic http://ionicframework.com - MIT License\r\n */\r\nimport { readTask, writeTask, proxyCustomElement, HTMLElement, h, Host } from '@stencil/core/internal/client';\r\nimport { g as getScrollElement, f as findIonContent, p as printIonContentErrorMsg } from './index8.js';\r\nimport { m as clamp, i as inheritAriaAttributes } from './helpers.js';\r\nimport { h as hostContext } from './theme.js';\r\nimport { b as getIonMode } from './ionic-global.js';\r\n\r\nconst TRANSITION = 'all 0.2s ease-in-out';\r\nconst cloneElement = (tagName) => {\r\n    const getCachedEl = document.querySelector(`${tagName}.ion-cloned-element`);\r\n    if (getCachedEl !== null) {\r\n        return getCachedEl;\r\n    }\r\n    const clonedEl = document.createElement(tagName);\r\n    clonedEl.classList.add('ion-cloned-element');\r\n    clonedEl.style.setProperty('display', 'none');\r\n    document.body.appendChild(clonedEl);\r\n    return clonedEl;\r\n};\r\nconst createHeaderIndex = (headerEl) => {\r\n    if (!headerEl) {\r\n        return;\r\n    }\r\n    const toolbars = headerEl.querySelectorAll('ion-toolbar');\r\n    return {\r\n        el: headerEl,\r\n        toolbars: Array.from(toolbars).map((toolbar) => {\r\n            const ionTitleEl = toolbar.querySelector('ion-title');\r\n            return {\r\n                el: toolbar,\r\n                background: toolbar.shadowRoot.querySelector('.toolbar-background'),\r\n                ionTitleEl,\r\n                innerTitleEl: ionTitleEl ? ionTitleEl.shadowRoot.querySelector('.toolbar-title') : null,\r\n                ionButtonsEl: Array.from(toolbar.querySelectorAll('ion-buttons')),\r\n            };\r\n        }),\r\n    };\r\n};\r\nconst handleContentScroll = (scrollEl, scrollHeaderIndex, contentEl) => {\r\n    readTask(() => {\r\n        const scrollTop = scrollEl.scrollTop;\r\n        const scale = clamp(1, 1 + -scrollTop / 500, 1.1);\r\n        // Native refresher should not cause titles to scale\r\n        const nativeRefresher = contentEl.querySelector('ion-refresher.refresher-native');\r\n        if (nativeRefresher === null) {\r\n            writeTask(() => {\r\n                scaleLargeTitles(scrollHeaderIndex.toolbars, scale);\r\n            });\r\n        }\r\n    });\r\n};\r\nconst setToolbarBackgroundOpacity = (headerEl, opacity) => {\r\n    /**\r\n     * Fading in the backdrop opacity\r\n     * should happen after the large title\r\n     * has collapsed, so it is handled\r\n     * by handleHeaderFade()\r\n     */\r\n    if (headerEl.collapse === 'fade') {\r\n        return;\r\n    }\r\n    if (opacity === undefined) {\r\n        headerEl.style.removeProperty('--opacity-scale');\r\n    }\r\n    else {\r\n        headerEl.style.setProperty('--opacity-scale', opacity.toString());\r\n    }\r\n};\r\nconst handleToolbarBorderIntersection = (ev, mainHeaderIndex, scrollTop) => {\r\n    if (!ev[0].isIntersecting) {\r\n        return;\r\n    }\r\n    /**\r\n     * There is a bug in Safari where overflow scrolling on a non-body element\r\n     * does not always reset the scrollTop position to 0 when letting go. It will\r\n     * set to 1 once the rubber band effect has ended. This causes the background to\r\n     * appear slightly on certain app setups.\r\n     *\r\n     * Additionally, we check if user is rubber banding (scrolling is negative)\r\n     * as this can mean they are using pull to refresh. Once the refresher starts,\r\n     * the content is transformed which can cause the intersection observer to erroneously\r\n     * fire here as well.\r\n     */\r\n    const scale = ev[0].intersectionRatio > 0.9 || scrollTop <= 0 ? 0 : ((1 - ev[0].intersectionRatio) * 100) / 75;\r\n    setToolbarBackgroundOpacity(mainHeaderIndex.el, scale === 1 ? undefined : scale);\r\n};\r\n/**\r\n * If toolbars are intersecting, hide the scrollable toolbar content\r\n * and show the primary toolbar content. If the toolbars are not intersecting,\r\n * hide the primary toolbar content and show the scrollable toolbar content\r\n */\r\nconst handleToolbarIntersection = (ev, // TODO(FW-2832): type (IntersectionObserverEntry[] triggers errors which should be sorted)\r\nmainHeaderIndex, scrollHeaderIndex, scrollEl) => {\r\n    writeTask(() => {\r\n        const scrollTop = scrollEl.scrollTop;\r\n        handleToolbarBorderIntersection(ev, mainHeaderIndex, scrollTop);\r\n        const event = ev[0];\r\n        const intersection = event.intersectionRect;\r\n        const intersectionArea = intersection.width * intersection.height;\r\n        const rootArea = event.rootBounds.width * event.rootBounds.height;\r\n        const isPageHidden = intersectionArea === 0 && rootArea === 0;\r\n        const leftDiff = Math.abs(intersection.left - event.boundingClientRect.left);\r\n        const rightDiff = Math.abs(intersection.right - event.boundingClientRect.right);\r\n        const isPageTransitioning = intersectionArea > 0 && (leftDiff >= 5 || rightDiff >= 5);\r\n        if (isPageHidden || isPageTransitioning) {\r\n            return;\r\n        }\r\n        if (event.isIntersecting) {\r\n            setHeaderActive(mainHeaderIndex, false);\r\n            setHeaderActive(scrollHeaderIndex);\r\n        }\r\n        else {\r\n            /**\r\n             * There is a bug with IntersectionObserver on Safari\r\n             * where `event.isIntersecting === false` when cancelling\r\n             * a swipe to go back gesture. Checking the intersection\r\n             * x, y, width, and height provides a workaround. This bug\r\n             * does not happen when using Safari + Web Animations,\r\n             * only Safari + CSS Animations.\r\n             */\r\n            const hasValidIntersection = (intersection.x === 0 && intersection.y === 0) || (intersection.width !== 0 && intersection.height !== 0);\r\n            if (hasValidIntersection && scrollTop > 0) {\r\n                setHeaderActive(mainHeaderIndex);\r\n                setHeaderActive(scrollHeaderIndex, false);\r\n                setToolbarBackgroundOpacity(mainHeaderIndex.el);\r\n            }\r\n        }\r\n    });\r\n};\r\nconst setHeaderActive = (headerIndex, active = true) => {\r\n    const headerEl = headerIndex.el;\r\n    if (active) {\r\n        headerEl.classList.remove('header-collapse-condense-inactive');\r\n        headerEl.removeAttribute('aria-hidden');\r\n    }\r\n    else {\r\n        headerEl.classList.add('header-collapse-condense-inactive');\r\n        headerEl.setAttribute('aria-hidden', 'true');\r\n    }\r\n};\r\nconst scaleLargeTitles = (toolbars = [], scale = 1, transition = false) => {\r\n    toolbars.forEach((toolbar) => {\r\n        const ionTitle = toolbar.ionTitleEl;\r\n        const titleDiv = toolbar.innerTitleEl;\r\n        if (!ionTitle || ionTitle.size !== 'large') {\r\n            return;\r\n        }\r\n        titleDiv.style.transition = transition ? TRANSITION : '';\r\n        titleDiv.style.transform = `scale3d(${scale}, ${scale}, 1)`;\r\n    });\r\n};\r\nconst handleHeaderFade = (scrollEl, baseEl, condenseHeader) => {\r\n    readTask(() => {\r\n        const scrollTop = scrollEl.scrollTop;\r\n        const baseElHeight = baseEl.clientHeight;\r\n        const fadeStart = condenseHeader ? condenseHeader.clientHeight : 0;\r\n        /**\r\n         * If we are using fade header with a condense\r\n         * header, then the toolbar backgrounds should\r\n         * not begin to fade in until the condense\r\n         * header has fully collapsed.\r\n         *\r\n         * Additionally, the main content should not\r\n         * overflow out of the container until the\r\n         * condense header has fully collapsed. When\r\n         * using just the condense header the content\r\n         * should overflow out of the container.\r\n         */\r\n        if (condenseHeader !== null && scrollTop < fadeStart) {\r\n            baseEl.style.setProperty('--opacity-scale', '0');\r\n            scrollEl.style.setProperty('clip-path', `inset(${baseElHeight}px 0px 0px 0px)`);\r\n            return;\r\n        }\r\n        const distanceToStart = scrollTop - fadeStart;\r\n        const fadeDuration = 10;\r\n        const scale = clamp(0, distanceToStart / fadeDuration, 1);\r\n        writeTask(() => {\r\n            scrollEl.style.removeProperty('clip-path');\r\n            baseEl.style.setProperty('--opacity-scale', scale.toString());\r\n        });\r\n    });\r\n};\r\n\r\nconst headerIosCss = \"ion-header{display:block;position:relative;-ms-flex-order:-1;order:-1;width:100%;z-index:10}ion-header ion-toolbar:first-of-type{padding-top:var(--ion-safe-area-top, 0)}.header-ios ion-toolbar:last-of-type{--border-width:0 0 0.55px}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){.header-background{left:0;right:0;top:0;bottom:0;position:absolute;-webkit-backdrop-filter:saturate(180%) blur(20px);backdrop-filter:saturate(180%) blur(20px)}.header-translucent-ios ion-toolbar{--opacity:.8}.header-collapse-condense-inactive .header-background{-webkit-backdrop-filter:blur(20px);backdrop-filter:blur(20px)}}.header-ios.ion-no-border ion-toolbar:last-of-type{--border-width:0}.header-collapse-fade ion-toolbar{--opacity-scale:inherit}.header-collapse-condense{z-index:9}.header-collapse-condense ion-toolbar{position:-webkit-sticky;position:sticky;top:0}.header-collapse-condense ion-toolbar:first-of-type{padding-top:0px;z-index:1}.header-collapse-condense ion-toolbar{--background:var(--ion-background-color, #fff);z-index:0}.header-collapse-condense ion-toolbar:last-of-type{--border-width:0px}.header-collapse-condense ion-toolbar ion-searchbar{padding-top:0px;padding-bottom:13px}.header-collapse-main{--opacity-scale:1}.header-collapse-main ion-toolbar{--opacity-scale:inherit}.header-collapse-main ion-toolbar.in-toolbar ion-title,.header-collapse-main ion-toolbar.in-toolbar ion-buttons{-webkit-transition:all 0.2s ease-in-out;transition:all 0.2s ease-in-out}.header-collapse-condense-inactive:not(.header-collapse-condense) ion-toolbar.in-toolbar ion-title,.header-collapse-condense-inactive:not(.header-collapse-condense) ion-toolbar.in-toolbar ion-buttons.buttons-collapse{opacity:0;pointer-events:none}.header-collapse-condense-inactive.header-collapse-condense ion-toolbar.in-toolbar ion-title,.header-collapse-condense-inactive.header-collapse-condense ion-toolbar.in-toolbar ion-buttons.buttons-collapse{visibility:hidden}ion-header.header-ios:not(.header-collapse-main):has(~ion-content ion-header.header-ios[collapse=condense],~ion-content ion-header.header-ios.header-collapse-condense){opacity:0}\";\r\nconst IonHeaderIosStyle0 = headerIosCss;\r\n\r\nconst headerMdCss = \"ion-header{display:block;position:relative;-ms-flex-order:-1;order:-1;width:100%;z-index:10}ion-header ion-toolbar:first-of-type{padding-top:var(--ion-safe-area-top, 0)}.header-md{-webkit-box-shadow:0 2px 4px -1px rgba(0, 0, 0, 0.2), 0 4px 5px 0 rgba(0, 0, 0, 0.14), 0 1px 10px 0 rgba(0, 0, 0, 0.12);box-shadow:0 2px 4px -1px rgba(0, 0, 0, 0.2), 0 4px 5px 0 rgba(0, 0, 0, 0.14), 0 1px 10px 0 rgba(0, 0, 0, 0.12)}.header-collapse-condense{display:none}.header-md.ion-no-border{-webkit-box-shadow:none;box-shadow:none}\";\r\nconst IonHeaderMdStyle0 = headerMdCss;\r\n\r\nconst Header = /*@__PURE__*/ proxyCustomElement(class Header extends HTMLElement {\r\n    constructor() {\r\n        super();\r\n        this.__registerHost();\r\n        this.inheritedAttributes = {};\r\n        this.setupFadeHeader = async (contentEl, condenseHeader) => {\r\n            const scrollEl = (this.scrollEl = await getScrollElement(contentEl));\r\n            /**\r\n             * Handle fading of toolbars on scroll\r\n             */\r\n            this.contentScrollCallback = () => {\r\n                handleHeaderFade(this.scrollEl, this.el, condenseHeader);\r\n            };\r\n            scrollEl.addEventListener('scroll', this.contentScrollCallback);\r\n            handleHeaderFade(this.scrollEl, this.el, condenseHeader);\r\n        };\r\n        this.collapse = undefined;\r\n        this.translucent = false;\r\n    }\r\n    componentWillLoad() {\r\n        this.inheritedAttributes = inheritAriaAttributes(this.el);\r\n    }\r\n    componentDidLoad() {\r\n        this.checkCollapsibleHeader();\r\n    }\r\n    componentDidUpdate() {\r\n        this.checkCollapsibleHeader();\r\n    }\r\n    disconnectedCallback() {\r\n        this.destroyCollapsibleHeader();\r\n    }\r\n    async checkCollapsibleHeader() {\r\n        const mode = getIonMode(this);\r\n        if (mode !== 'ios') {\r\n            return;\r\n        }\r\n        const { collapse } = this;\r\n        const hasCondense = collapse === 'condense';\r\n        const hasFade = collapse === 'fade';\r\n        this.destroyCollapsibleHeader();\r\n        if (hasCondense) {\r\n            const pageEl = this.el.closest('ion-app,ion-page,.ion-page,page-inner');\r\n            const contentEl = pageEl ? findIonContent(pageEl) : null;\r\n            // Cloned elements are always needed in iOS transition\r\n            writeTask(() => {\r\n                const title = cloneElement('ion-title');\r\n                title.size = 'large';\r\n                cloneElement('ion-back-button');\r\n            });\r\n            await this.setupCondenseHeader(contentEl, pageEl);\r\n        }\r\n        else if (hasFade) {\r\n            const pageEl = this.el.closest('ion-app,ion-page,.ion-page,page-inner');\r\n            const contentEl = pageEl ? findIonContent(pageEl) : null;\r\n            if (!contentEl) {\r\n                printIonContentErrorMsg(this.el);\r\n                return;\r\n            }\r\n            const condenseHeader = contentEl.querySelector('ion-header[collapse=\"condense\"]');\r\n            await this.setupFadeHeader(contentEl, condenseHeader);\r\n        }\r\n    }\r\n    destroyCollapsibleHeader() {\r\n        if (this.intersectionObserver) {\r\n            this.intersectionObserver.disconnect();\r\n            this.intersectionObserver = undefined;\r\n        }\r\n        if (this.scrollEl && this.contentScrollCallback) {\r\n            this.scrollEl.removeEventListener('scroll', this.contentScrollCallback);\r\n            this.contentScrollCallback = undefined;\r\n        }\r\n        if (this.collapsibleMainHeader) {\r\n            this.collapsibleMainHeader.classList.remove('header-collapse-main');\r\n            this.collapsibleMainHeader = undefined;\r\n        }\r\n    }\r\n    async setupCondenseHeader(contentEl, pageEl) {\r\n        if (!contentEl || !pageEl) {\r\n            printIonContentErrorMsg(this.el);\r\n            return;\r\n        }\r\n        if (typeof IntersectionObserver === 'undefined') {\r\n            return;\r\n        }\r\n        this.scrollEl = await getScrollElement(contentEl);\r\n        const headers = pageEl.querySelectorAll('ion-header');\r\n        this.collapsibleMainHeader = Array.from(headers).find((header) => header.collapse !== 'condense');\r\n        if (!this.collapsibleMainHeader) {\r\n            return;\r\n        }\r\n        const mainHeaderIndex = createHeaderIndex(this.collapsibleMainHeader);\r\n        const scrollHeaderIndex = createHeaderIndex(this.el);\r\n        if (!mainHeaderIndex || !scrollHeaderIndex) {\r\n            return;\r\n        }\r\n        setHeaderActive(mainHeaderIndex, false);\r\n        setToolbarBackgroundOpacity(mainHeaderIndex.el, 0);\r\n        /**\r\n         * Handle interaction between toolbar collapse and\r\n         * showing/hiding content in the primary ion-header\r\n         * as well as progressively showing/hiding the main header\r\n         * border as the top-most toolbar collapses or expands.\r\n         */\r\n        const toolbarIntersection = (ev) => {\r\n            handleToolbarIntersection(ev, mainHeaderIndex, scrollHeaderIndex, this.scrollEl);\r\n        };\r\n        this.intersectionObserver = new IntersectionObserver(toolbarIntersection, {\r\n            root: contentEl,\r\n            threshold: [0.25, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1],\r\n        });\r\n        this.intersectionObserver.observe(scrollHeaderIndex.toolbars[scrollHeaderIndex.toolbars.length - 1].el);\r\n        /**\r\n         * Handle scaling of large iOS titles and\r\n         * showing/hiding border on last toolbar\r\n         * in primary header\r\n         */\r\n        this.contentScrollCallback = () => {\r\n            handleContentScroll(this.scrollEl, scrollHeaderIndex, contentEl);\r\n        };\r\n        this.scrollEl.addEventListener('scroll', this.contentScrollCallback);\r\n        writeTask(() => {\r\n            if (this.collapsibleMainHeader !== undefined) {\r\n                this.collapsibleMainHeader.classList.add('header-collapse-main');\r\n            }\r\n        });\r\n    }\r\n    render() {\r\n        const { translucent, inheritedAttributes } = this;\r\n        const mode = getIonMode(this);\r\n        const collapse = this.collapse || 'none';\r\n        // banner role must be at top level, so remove role if inside a menu\r\n        const roleType = hostContext('ion-menu', this.el) ? 'none' : 'banner';\r\n        return (h(Host, Object.assign({ key: 'be4386a218c20dc4c18320dbbcfb25574d13d27e', role: roleType, class: {\r\n                [mode]: true,\r\n                // Used internally for styling\r\n                [`header-${mode}`]: true,\r\n                [`header-translucent`]: this.translucent,\r\n                [`header-collapse-${collapse}`]: true,\r\n                [`header-translucent-${mode}`]: this.translucent,\r\n            } }, inheritedAttributes), mode === 'ios' && translucent && h(\"div\", { class: \"header-background\" }), h(\"slot\", { key: '74c401fb331aeb40c733605fd580949ad53989b8' })));\r\n    }\r\n    get el() { return this; }\r\n    static get style() { return {\r\n        ios: IonHeaderIosStyle0,\r\n        md: IonHeaderMdStyle0\r\n    }; }\r\n}, [36, \"ion-header\", {\r\n        \"collapse\": [1],\r\n        \"translucent\": [4]\r\n    }]);\r\nfunction defineCustomElement$1() {\r\n    if (typeof customElements === \"undefined\") {\r\n        return;\r\n    }\r\n    const components = [\"ion-header\"];\r\n    components.forEach(tagName => { switch (tagName) {\r\n        case \"ion-header\":\r\n            if (!customElements.get(tagName)) {\r\n                customElements.define(tagName, Header);\r\n            }\r\n            break;\r\n    } });\r\n}\r\n\r\nconst IonHeader = Header;\r\nconst defineCustomElement = defineCustomElement$1;\r\n\r\nexport { IonHeader, defineCustomElement };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}