{"ast":null,"code":"/*!\r\n * (C) Ionic http://ionicframework.com - MIT License\r\n */\nimport { proxyCustomElement, HTMLElement, createEvent, h, Host } from '@stencil/core/internal/client';\nimport { a as findClosestIonContent, d as disableContentScrollY, r as resetContentScrollY } from './index8.js';\nimport { o as isEndSide } from './helpers.js';\nimport { w as watchForOptions } from './watch-options.js';\nimport { b as getIonMode } from './ionic-global.js';\nconst itemSlidingCss = \"ion-item-sliding{display:block;position:relative;width:100%;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}ion-item-sliding .item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.item-sliding-active-slide .item{position:relative;-webkit-transition:-webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:-webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1), -webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);opacity:1;z-index:2;pointer-events:none;will-change:transform}.item-sliding-closing ion-item-options{pointer-events:none}.item-sliding-active-swipe-end .item-options-end .item-option-expandable{padding-left:100%;-ms-flex-order:1;order:1;-webkit-transition-duration:0.6s;transition-duration:0.6s;-webkit-transition-property:padding-left;transition-property:padding-left}:host-context([dir=rtl]) .item-sliding-active-swipe-end .item-options-end .item-option-expandable{-ms-flex-order:-1;order:-1}[dir=rtl] .item-sliding-active-swipe-end .item-options-end .item-option-expandable{-ms-flex-order:-1;order:-1}@supports selector(:dir(rtl)){.item-sliding-active-swipe-end .item-options-end .item-option-expandable:dir(rtl){-ms-flex-order:-1;order:-1}}.item-sliding-active-swipe-start .item-options-start .item-option-expandable{padding-right:100%;-ms-flex-order:-1;order:-1;-webkit-transition-duration:0.6s;transition-duration:0.6s;-webkit-transition-property:padding-right;transition-property:padding-right}:host-context([dir=rtl]) .item-sliding-active-swipe-start .item-options-start .item-option-expandable{-ms-flex-order:1;order:1}[dir=rtl] .item-sliding-active-swipe-start .item-options-start .item-option-expandable{-ms-flex-order:1;order:1}@supports selector(:dir(rtl)){.item-sliding-active-swipe-start .item-options-start .item-option-expandable:dir(rtl){-ms-flex-order:1;order:1}}\";\nconst IonItemSlidingStyle0 = itemSlidingCss;\nconst SWIPE_MARGIN = 30;\nconst ELASTIC_FACTOR = 0.55;\nlet openSlidingItem;\nconst ItemSliding = /*@__PURE__*/proxyCustomElement(class ItemSliding extends HTMLElement {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.ionDrag = createEvent(this, \"ionDrag\", 7);\n    this.item = null;\n    this.openAmount = 0;\n    this.initialOpenAmount = 0;\n    this.optsWidthRightSide = 0;\n    this.optsWidthLeftSide = 0;\n    this.sides = 0 /* ItemSide.None */;\n    this.optsDirty = true;\n    this.contentEl = null;\n    this.initialContentScrollY = true;\n    this.state = 2 /* SlidingState.Disabled */;\n    this.disabled = false;\n  }\n  disabledChanged() {\n    if (this.gesture) {\n      this.gesture.enable(!this.disabled);\n    }\n  }\n  async connectedCallback() {\n    const {\n      el\n    } = this;\n    this.item = el.querySelector('ion-item');\n    this.contentEl = findClosestIonContent(el);\n    /**\r\n     * The MutationObserver needs to be added before we\r\n     * call updateOptions below otherwise we may miss\r\n     * ion-item-option elements that are added to the DOM\r\n     * while updateOptions is running and before the MutationObserver\r\n     * has been initialized.\r\n     */\n    this.mutationObserver = watchForOptions(el, 'ion-item-option', async () => {\n      await this.updateOptions();\n    });\n    await this.updateOptions();\n    this.gesture = (await import('./index3.js')).createGesture({\n      el,\n      gestureName: 'item-swipe',\n      gesturePriority: 100,\n      threshold: 5,\n      canStart: ev => this.canStart(ev),\n      onStart: () => this.onStart(),\n      onMove: ev => this.onMove(ev),\n      onEnd: ev => this.onEnd(ev)\n    });\n    this.disabledChanged();\n  }\n  disconnectedCallback() {\n    if (this.gesture) {\n      this.gesture.destroy();\n      this.gesture = undefined;\n    }\n    this.item = null;\n    this.leftOptions = this.rightOptions = undefined;\n    if (openSlidingItem === this.el) {\n      openSlidingItem = undefined;\n    }\n    if (this.mutationObserver) {\n      this.mutationObserver.disconnect();\n      this.mutationObserver = undefined;\n    }\n  }\n  /**\r\n   * Get the amount the item is open in pixels.\r\n   */\n  getOpenAmount() {\n    return Promise.resolve(this.openAmount);\n  }\n  /**\r\n   * Get the ratio of the open amount of the item compared to the width of the options.\r\n   * If the number returned is positive, then the options on the right side are open.\r\n   * If the number returned is negative, then the options on the left side are open.\r\n   * If the absolute value of the number is greater than 1, the item is open more than\r\n   * the width of the options.\r\n   */\n  getSlidingRatio() {\n    return Promise.resolve(this.getSlidingRatioSync());\n  }\n  /**\r\n   * Open the sliding item.\r\n   *\r\n   * @param side The side of the options to open. If a side is not provided, it will open the first set of options it finds within the item.\r\n   */\n  async open(side) {\n    var _a;\n    /**\r\n     * It is possible for the item to be added to the DOM\r\n     * after the item-sliding component was created. As a result,\r\n     * if this.item is null, then we should attempt to\r\n     * query for the ion-item again.\r\n     * However, if the item is already defined then\r\n     * we do not query for it again.\r\n     */\n    const item = this.item = (_a = this.item) !== null && _a !== void 0 ? _a : this.el.querySelector('ion-item');\n    if (item === null) {\n      return;\n    }\n    const optionsToOpen = this.getOptions(side);\n    if (!optionsToOpen) {\n      return;\n    }\n    /**\r\n     * If side is not set, we need to infer the side\r\n     * so we know which direction to move the options\r\n     */\n    if (side === undefined) {\n      side = optionsToOpen === this.leftOptions ? 'start' : 'end';\n    }\n    // In RTL we want to switch the sides\n    side = isEndSide(side) ? 'end' : 'start';\n    const isStartOpen = this.openAmount < 0;\n    const isEndOpen = this.openAmount > 0;\n    /**\r\n     * If a side is open and a user tries to\r\n     * re-open the same side, we should not do anything\r\n     */\n    if (isStartOpen && optionsToOpen === this.leftOptions) {\n      return;\n    }\n    if (isEndOpen && optionsToOpen === this.rightOptions) {\n      return;\n    }\n    this.closeOpened();\n    this.state = 4 /* SlidingState.Enabled */;\n    requestAnimationFrame(() => {\n      this.calculateOptsWidth();\n      const width = side === 'end' ? this.optsWidthRightSide : -this.optsWidthLeftSide;\n      openSlidingItem = this.el;\n      this.setOpenAmount(width, false);\n      this.state = side === 'end' ? 8 /* SlidingState.End */ : 16 /* SlidingState.Start */;\n    });\n  }\n  /**\r\n   * Close the sliding item. Items can also be closed from the [List](./list).\r\n   */\n  async close() {\n    this.setOpenAmount(0, true);\n  }\n  /**\r\n   * Close all of the sliding items in the list. Items can also be closed from the [List](./list).\r\n   */\n  async closeOpened() {\n    if (openSlidingItem !== undefined) {\n      openSlidingItem.close();\n      openSlidingItem = undefined;\n      return true;\n    }\n    return false;\n  }\n  /**\r\n   * Given an optional side, return the ion-item-options element.\r\n   *\r\n   * @param side This side of the options to get. If a side is not provided it will\r\n   * return the first one available.\r\n   */\n  getOptions(side) {\n    if (side === undefined) {\n      return this.leftOptions || this.rightOptions;\n    } else if (side === 'start') {\n      return this.leftOptions;\n    } else {\n      return this.rightOptions;\n    }\n  }\n  async updateOptions() {\n    const options = this.el.querySelectorAll('ion-item-options');\n    let sides = 0;\n    // Reset left and right options in case they were removed\n    this.leftOptions = this.rightOptions = undefined;\n    for (let i = 0; i < options.length; i++) {\n      const item = options.item(i);\n      /**\r\n       * We cannot use the componentOnReady helper\r\n       * util here since we need to wait for all of these items\r\n       * to be ready before we set `this.sides` and `this.optsDirty`.\r\n       */\n      // eslint-disable-next-line custom-rules/no-component-on-ready-method\n      const option = item.componentOnReady !== undefined ? await item.componentOnReady() : item;\n      const side = isEndSide(option.side) ? 'end' : 'start';\n      if (side === 'start') {\n        this.leftOptions = option;\n        sides |= 1 /* ItemSide.Start */;\n      } else {\n        this.rightOptions = option;\n        sides |= 2 /* ItemSide.End */;\n      }\n    }\n    this.optsDirty = true;\n    this.sides = sides;\n  }\n  canStart(gesture) {\n    /**\r\n     * If very close to start of the screen\r\n     * do not open left side so swipe to go\r\n     * back will still work.\r\n     */\n    const rtl = document.dir === 'rtl';\n    const atEdge = rtl ? window.innerWidth - gesture.startX < 15 : gesture.startX < 15;\n    if (atEdge) {\n      return false;\n    }\n    const selected = openSlidingItem;\n    if (selected && selected !== this.el) {\n      this.closeOpened();\n    }\n    return !!(this.rightOptions || this.leftOptions);\n  }\n  onStart() {\n    /**\r\n     * We need to query for the ion-item\r\n     * every time the gesture starts. Developers\r\n     * may toggle ion-item elements via *ngIf.\r\n     */\n    this.item = this.el.querySelector('ion-item');\n    const {\n      contentEl\n    } = this;\n    if (contentEl) {\n      this.initialContentScrollY = disableContentScrollY(contentEl);\n    }\n    openSlidingItem = this.el;\n    if (this.tmr !== undefined) {\n      clearTimeout(this.tmr);\n      this.tmr = undefined;\n    }\n    if (this.openAmount === 0) {\n      this.optsDirty = true;\n      this.state = 4 /* SlidingState.Enabled */;\n    }\n    this.initialOpenAmount = this.openAmount;\n    if (this.item) {\n      this.item.style.transition = 'none';\n    }\n  }\n  onMove(gesture) {\n    if (this.optsDirty) {\n      this.calculateOptsWidth();\n    }\n    let openAmount = this.initialOpenAmount - gesture.deltaX;\n    switch (this.sides) {\n      case 2 /* ItemSide.End */:\n        openAmount = Math.max(0, openAmount);\n        break;\n      case 1 /* ItemSide.Start */:\n        openAmount = Math.min(0, openAmount);\n        break;\n      case 3 /* ItemSide.Both */:\n        break;\n      case 0 /* ItemSide.None */:\n        return;\n      default:\n        console.warn('invalid ItemSideFlags value', this.sides);\n        break;\n    }\n    let optsWidth;\n    if (openAmount > this.optsWidthRightSide) {\n      optsWidth = this.optsWidthRightSide;\n      openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;\n    } else if (openAmount < -this.optsWidthLeftSide) {\n      optsWidth = -this.optsWidthLeftSide;\n      openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;\n    }\n    this.setOpenAmount(openAmount, false);\n  }\n  onEnd(gesture) {\n    const {\n      contentEl,\n      initialContentScrollY\n    } = this;\n    if (contentEl) {\n      resetContentScrollY(contentEl, initialContentScrollY);\n    }\n    const velocity = gesture.velocityX;\n    let restingPoint = this.openAmount > 0 ? this.optsWidthRightSide : -this.optsWidthLeftSide;\n    // Check if the drag didn't clear the buttons mid-point\n    // and we aren't moving fast enough to swipe open\n    const isResetDirection = this.openAmount > 0 === !(velocity < 0);\n    const isMovingFast = Math.abs(velocity) > 0.3;\n    const isOnCloseZone = Math.abs(this.openAmount) < Math.abs(restingPoint / 2);\n    if (swipeShouldReset(isResetDirection, isMovingFast, isOnCloseZone)) {\n      restingPoint = 0;\n    }\n    const state = this.state;\n    this.setOpenAmount(restingPoint, true);\n    if ((state & 32 /* SlidingState.SwipeEnd */) !== 0 && this.rightOptions) {\n      this.rightOptions.fireSwipeEvent();\n    } else if ((state & 64 /* SlidingState.SwipeStart */) !== 0 && this.leftOptions) {\n      this.leftOptions.fireSwipeEvent();\n    }\n  }\n  calculateOptsWidth() {\n    this.optsWidthRightSide = 0;\n    if (this.rightOptions) {\n      this.rightOptions.style.display = 'flex';\n      this.optsWidthRightSide = this.rightOptions.offsetWidth;\n      this.rightOptions.style.display = '';\n    }\n    this.optsWidthLeftSide = 0;\n    if (this.leftOptions) {\n      this.leftOptions.style.display = 'flex';\n      this.optsWidthLeftSide = this.leftOptions.offsetWidth;\n      this.leftOptions.style.display = '';\n    }\n    this.optsDirty = false;\n  }\n  setOpenAmount(openAmount, isFinal) {\n    if (this.tmr !== undefined) {\n      clearTimeout(this.tmr);\n      this.tmr = undefined;\n    }\n    if (!this.item) {\n      return;\n    }\n    const {\n      el\n    } = this;\n    const style = this.item.style;\n    this.openAmount = openAmount;\n    if (isFinal) {\n      style.transition = '';\n    }\n    if (openAmount > 0) {\n      this.state = openAmount >= this.optsWidthRightSide + SWIPE_MARGIN ? 8 /* SlidingState.End */ | 32 /* SlidingState.SwipeEnd */ : 8 /* SlidingState.End */;\n    } else if (openAmount < 0) {\n      this.state = openAmount <= -this.optsWidthLeftSide - SWIPE_MARGIN ? 16 /* SlidingState.Start */ | 64 /* SlidingState.SwipeStart */ : 16 /* SlidingState.Start */;\n    } else {\n      /**\r\n       * The sliding options should not be\r\n       * clickable while the item is closing.\r\n       */\n      el.classList.add('item-sliding-closing');\n      /**\r\n       * Item sliding cannot be interrupted\r\n       * while closing the item. If it did,\r\n       * it would allow the item to get into an\r\n       * inconsistent state where multiple\r\n       * items are then open at the same time.\r\n       */\n      if (this.gesture) {\n        this.gesture.enable(false);\n      }\n      this.tmr = setTimeout(() => {\n        this.state = 2 /* SlidingState.Disabled */;\n        this.tmr = undefined;\n        if (this.gesture) {\n          this.gesture.enable(!this.disabled);\n        }\n        el.classList.remove('item-sliding-closing');\n      }, 600);\n      openSlidingItem = undefined;\n      style.transform = '';\n      return;\n    }\n    style.transform = `translate3d(${-openAmount}px,0,0)`;\n    this.ionDrag.emit({\n      amount: openAmount,\n      ratio: this.getSlidingRatioSync()\n    });\n  }\n  getSlidingRatioSync() {\n    if (this.openAmount > 0) {\n      return this.openAmount / this.optsWidthRightSide;\n    } else if (this.openAmount < 0) {\n      return this.openAmount / this.optsWidthLeftSide;\n    } else {\n      return 0;\n    }\n  }\n  render() {\n    const mode = getIonMode(this);\n    return h(Host, {\n      key: '83e1673fc5af892612deb9b49d5e792b8b0b6473',\n      class: {\n        [mode]: true,\n        'item-sliding-active-slide': this.state !== 2 /* SlidingState.Disabled */,\n        'item-sliding-active-options-end': (this.state & 8 /* SlidingState.End */) !== 0,\n        'item-sliding-active-options-start': (this.state & 16 /* SlidingState.Start */) !== 0,\n        'item-sliding-active-swipe-end': (this.state & 32 /* SlidingState.SwipeEnd */) !== 0,\n        'item-sliding-active-swipe-start': (this.state & 64 /* SlidingState.SwipeStart */) !== 0\n      }\n    });\n  }\n  get el() {\n    return this;\n  }\n  static get watchers() {\n    return {\n      \"disabled\": [\"disabledChanged\"]\n    };\n  }\n  static get style() {\n    return IonItemSlidingStyle0;\n  }\n}, [0, \"ion-item-sliding\", {\n  \"disabled\": [4],\n  \"state\": [32],\n  \"getOpenAmount\": [64],\n  \"getSlidingRatio\": [64],\n  \"open\": [64],\n  \"close\": [64],\n  \"closeOpened\": [64]\n}, undefined, {\n  \"disabled\": [\"disabledChanged\"]\n}]);\nconst swipeShouldReset = (isResetDirection, isMovingFast, isOnResetZone) => {\n  // The logic required to know when the sliding item should close (openAmount=0)\n  // depends on three booleans (isResetDirection, isMovingFast, isOnResetZone)\n  // and it ended up being too complicated to be written manually without errors\n  // so the truth table is attached below: (0=false, 1=true)\n  // isResetDirection | isMovingFast | isOnResetZone || shouldClose\n  //         0        |       0      |       0       ||    0\n  //         0        |       0      |       1       ||    1\n  //         0        |       1      |       0       ||    0\n  //         0        |       1      |       1       ||    0\n  //         1        |       0      |       0       ||    0\n  //         1        |       0      |       1       ||    1\n  //         1        |       1      |       0       ||    1\n  //         1        |       1      |       1       ||    1\n  // The resulting expression was generated by resolving the K-map (Karnaugh map):\n  return !isMovingFast && isOnResetZone || isResetDirection && isMovingFast;\n};\nfunction defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-item-sliding\"];\n  components.forEach(tagName => {\n    switch (tagName) {\n      case \"ion-item-sliding\":\n        if (!customElements.get(tagName)) {\n          customElements.define(tagName, ItemSliding);\n        }\n        break;\n    }\n  });\n}\nconst IonItemSliding = ItemSliding;\nconst defineCustomElement = defineCustomElement$1;\nexport { IonItemSliding, defineCustomElement };","map":{"version":3,"names":["proxyCustomElement","HTMLElement","createEvent","h","Host","a","findClosestIonContent","d","disableContentScrollY","r","resetContentScrollY","o","isEndSide","w","watchForOptions","b","getIonMode","itemSlidingCss","IonItemSlidingStyle0","SWIPE_MARGIN","ELASTIC_FACTOR","openSlidingItem","ItemSliding","constructor","__registerHost","ionDrag","item","openAmount","initialOpenAmount","optsWidthRightSide","optsWidthLeftSide","sides","optsDirty","contentEl","initialContentScrollY","state","disabled","disabledChanged","gesture","enable","connectedCallback","el","querySelector","mutationObserver","updateOptions","createGesture","gestureName","gesturePriority","threshold","canStart","ev","onStart","onMove","onEnd","disconnectedCallback","destroy","undefined","leftOptions","rightOptions","disconnect","getOpenAmount","Promise","resolve","getSlidingRatio","getSlidingRatioSync","open","side","_a","optionsToOpen","getOptions","isStartOpen","isEndOpen","closeOpened","requestAnimationFrame","calculateOptsWidth","width","setOpenAmount","close","options","querySelectorAll","i","length","option","componentOnReady","rtl","document","dir","atEdge","window","innerWidth","startX","selected","tmr","clearTimeout","style","transition","deltaX","Math","max","min","console","warn","optsWidth","velocity","velocityX","restingPoint","isResetDirection","isMovingFast","abs","isOnCloseZone","swipeShouldReset","fireSwipeEvent","display","offsetWidth","isFinal","classList","add","setTimeout","remove","transform","emit","amount","ratio","render","mode","key","class","watchers","isOnResetZone","defineCustomElement$1","customElements","components","forEach","tagName","get","define","IonItemSliding","defineCustomElement"],"sources":["E:/Online-Voting-Portal/client/node_modules/@ionic/core/components/ion-item-sliding.js"],"sourcesContent":["/*!\r\n * (C) Ionic http://ionicframework.com - MIT License\r\n */\r\nimport { proxyCustomElement, HTMLElement, createEvent, h, Host } from '@stencil/core/internal/client';\r\nimport { a as findClosestIonContent, d as disableContentScrollY, r as resetContentScrollY } from './index8.js';\r\nimport { o as isEndSide } from './helpers.js';\r\nimport { w as watchForOptions } from './watch-options.js';\r\nimport { b as getIonMode } from './ionic-global.js';\r\n\r\nconst itemSlidingCss = \"ion-item-sliding{display:block;position:relative;width:100%;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}ion-item-sliding .item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.item-sliding-active-slide .item{position:relative;-webkit-transition:-webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:-webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1), -webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);opacity:1;z-index:2;pointer-events:none;will-change:transform}.item-sliding-closing ion-item-options{pointer-events:none}.item-sliding-active-swipe-end .item-options-end .item-option-expandable{padding-left:100%;-ms-flex-order:1;order:1;-webkit-transition-duration:0.6s;transition-duration:0.6s;-webkit-transition-property:padding-left;transition-property:padding-left}:host-context([dir=rtl]) .item-sliding-active-swipe-end .item-options-end .item-option-expandable{-ms-flex-order:-1;order:-1}[dir=rtl] .item-sliding-active-swipe-end .item-options-end .item-option-expandable{-ms-flex-order:-1;order:-1}@supports selector(:dir(rtl)){.item-sliding-active-swipe-end .item-options-end .item-option-expandable:dir(rtl){-ms-flex-order:-1;order:-1}}.item-sliding-active-swipe-start .item-options-start .item-option-expandable{padding-right:100%;-ms-flex-order:-1;order:-1;-webkit-transition-duration:0.6s;transition-duration:0.6s;-webkit-transition-property:padding-right;transition-property:padding-right}:host-context([dir=rtl]) .item-sliding-active-swipe-start .item-options-start .item-option-expandable{-ms-flex-order:1;order:1}[dir=rtl] .item-sliding-active-swipe-start .item-options-start .item-option-expandable{-ms-flex-order:1;order:1}@supports selector(:dir(rtl)){.item-sliding-active-swipe-start .item-options-start .item-option-expandable:dir(rtl){-ms-flex-order:1;order:1}}\";\r\nconst IonItemSlidingStyle0 = itemSlidingCss;\r\n\r\nconst SWIPE_MARGIN = 30;\r\nconst ELASTIC_FACTOR = 0.55;\r\nlet openSlidingItem;\r\nconst ItemSliding = /*@__PURE__*/ proxyCustomElement(class ItemSliding extends HTMLElement {\r\n    constructor() {\r\n        super();\r\n        this.__registerHost();\r\n        this.ionDrag = createEvent(this, \"ionDrag\", 7);\r\n        this.item = null;\r\n        this.openAmount = 0;\r\n        this.initialOpenAmount = 0;\r\n        this.optsWidthRightSide = 0;\r\n        this.optsWidthLeftSide = 0;\r\n        this.sides = 0 /* ItemSide.None */;\r\n        this.optsDirty = true;\r\n        this.contentEl = null;\r\n        this.initialContentScrollY = true;\r\n        this.state = 2 /* SlidingState.Disabled */;\r\n        this.disabled = false;\r\n    }\r\n    disabledChanged() {\r\n        if (this.gesture) {\r\n            this.gesture.enable(!this.disabled);\r\n        }\r\n    }\r\n    async connectedCallback() {\r\n        const { el } = this;\r\n        this.item = el.querySelector('ion-item');\r\n        this.contentEl = findClosestIonContent(el);\r\n        /**\r\n         * The MutationObserver needs to be added before we\r\n         * call updateOptions below otherwise we may miss\r\n         * ion-item-option elements that are added to the DOM\r\n         * while updateOptions is running and before the MutationObserver\r\n         * has been initialized.\r\n         */\r\n        this.mutationObserver = watchForOptions(el, 'ion-item-option', async () => {\r\n            await this.updateOptions();\r\n        });\r\n        await this.updateOptions();\r\n        this.gesture = (await import('./index3.js')).createGesture({\r\n            el,\r\n            gestureName: 'item-swipe',\r\n            gesturePriority: 100,\r\n            threshold: 5,\r\n            canStart: (ev) => this.canStart(ev),\r\n            onStart: () => this.onStart(),\r\n            onMove: (ev) => this.onMove(ev),\r\n            onEnd: (ev) => this.onEnd(ev),\r\n        });\r\n        this.disabledChanged();\r\n    }\r\n    disconnectedCallback() {\r\n        if (this.gesture) {\r\n            this.gesture.destroy();\r\n            this.gesture = undefined;\r\n        }\r\n        this.item = null;\r\n        this.leftOptions = this.rightOptions = undefined;\r\n        if (openSlidingItem === this.el) {\r\n            openSlidingItem = undefined;\r\n        }\r\n        if (this.mutationObserver) {\r\n            this.mutationObserver.disconnect();\r\n            this.mutationObserver = undefined;\r\n        }\r\n    }\r\n    /**\r\n     * Get the amount the item is open in pixels.\r\n     */\r\n    getOpenAmount() {\r\n        return Promise.resolve(this.openAmount);\r\n    }\r\n    /**\r\n     * Get the ratio of the open amount of the item compared to the width of the options.\r\n     * If the number returned is positive, then the options on the right side are open.\r\n     * If the number returned is negative, then the options on the left side are open.\r\n     * If the absolute value of the number is greater than 1, the item is open more than\r\n     * the width of the options.\r\n     */\r\n    getSlidingRatio() {\r\n        return Promise.resolve(this.getSlidingRatioSync());\r\n    }\r\n    /**\r\n     * Open the sliding item.\r\n     *\r\n     * @param side The side of the options to open. If a side is not provided, it will open the first set of options it finds within the item.\r\n     */\r\n    async open(side) {\r\n        var _a;\r\n        /**\r\n         * It is possible for the item to be added to the DOM\r\n         * after the item-sliding component was created. As a result,\r\n         * if this.item is null, then we should attempt to\r\n         * query for the ion-item again.\r\n         * However, if the item is already defined then\r\n         * we do not query for it again.\r\n         */\r\n        const item = (this.item = (_a = this.item) !== null && _a !== void 0 ? _a : this.el.querySelector('ion-item'));\r\n        if (item === null) {\r\n            return;\r\n        }\r\n        const optionsToOpen = this.getOptions(side);\r\n        if (!optionsToOpen) {\r\n            return;\r\n        }\r\n        /**\r\n         * If side is not set, we need to infer the side\r\n         * so we know which direction to move the options\r\n         */\r\n        if (side === undefined) {\r\n            side = optionsToOpen === this.leftOptions ? 'start' : 'end';\r\n        }\r\n        // In RTL we want to switch the sides\r\n        side = isEndSide(side) ? 'end' : 'start';\r\n        const isStartOpen = this.openAmount < 0;\r\n        const isEndOpen = this.openAmount > 0;\r\n        /**\r\n         * If a side is open and a user tries to\r\n         * re-open the same side, we should not do anything\r\n         */\r\n        if (isStartOpen && optionsToOpen === this.leftOptions) {\r\n            return;\r\n        }\r\n        if (isEndOpen && optionsToOpen === this.rightOptions) {\r\n            return;\r\n        }\r\n        this.closeOpened();\r\n        this.state = 4 /* SlidingState.Enabled */;\r\n        requestAnimationFrame(() => {\r\n            this.calculateOptsWidth();\r\n            const width = side === 'end' ? this.optsWidthRightSide : -this.optsWidthLeftSide;\r\n            openSlidingItem = this.el;\r\n            this.setOpenAmount(width, false);\r\n            this.state = side === 'end' ? 8 /* SlidingState.End */ : 16 /* SlidingState.Start */;\r\n        });\r\n    }\r\n    /**\r\n     * Close the sliding item. Items can also be closed from the [List](./list).\r\n     */\r\n    async close() {\r\n        this.setOpenAmount(0, true);\r\n    }\r\n    /**\r\n     * Close all of the sliding items in the list. Items can also be closed from the [List](./list).\r\n     */\r\n    async closeOpened() {\r\n        if (openSlidingItem !== undefined) {\r\n            openSlidingItem.close();\r\n            openSlidingItem = undefined;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Given an optional side, return the ion-item-options element.\r\n     *\r\n     * @param side This side of the options to get. If a side is not provided it will\r\n     * return the first one available.\r\n     */\r\n    getOptions(side) {\r\n        if (side === undefined) {\r\n            return this.leftOptions || this.rightOptions;\r\n        }\r\n        else if (side === 'start') {\r\n            return this.leftOptions;\r\n        }\r\n        else {\r\n            return this.rightOptions;\r\n        }\r\n    }\r\n    async updateOptions() {\r\n        const options = this.el.querySelectorAll('ion-item-options');\r\n        let sides = 0;\r\n        // Reset left and right options in case they were removed\r\n        this.leftOptions = this.rightOptions = undefined;\r\n        for (let i = 0; i < options.length; i++) {\r\n            const item = options.item(i);\r\n            /**\r\n             * We cannot use the componentOnReady helper\r\n             * util here since we need to wait for all of these items\r\n             * to be ready before we set `this.sides` and `this.optsDirty`.\r\n             */\r\n            // eslint-disable-next-line custom-rules/no-component-on-ready-method\r\n            const option = item.componentOnReady !== undefined ? await item.componentOnReady() : item;\r\n            const side = isEndSide(option.side) ? 'end' : 'start';\r\n            if (side === 'start') {\r\n                this.leftOptions = option;\r\n                sides |= 1 /* ItemSide.Start */;\r\n            }\r\n            else {\r\n                this.rightOptions = option;\r\n                sides |= 2 /* ItemSide.End */;\r\n            }\r\n        }\r\n        this.optsDirty = true;\r\n        this.sides = sides;\r\n    }\r\n    canStart(gesture) {\r\n        /**\r\n         * If very close to start of the screen\r\n         * do not open left side so swipe to go\r\n         * back will still work.\r\n         */\r\n        const rtl = document.dir === 'rtl';\r\n        const atEdge = rtl ? window.innerWidth - gesture.startX < 15 : gesture.startX < 15;\r\n        if (atEdge) {\r\n            return false;\r\n        }\r\n        const selected = openSlidingItem;\r\n        if (selected && selected !== this.el) {\r\n            this.closeOpened();\r\n        }\r\n        return !!(this.rightOptions || this.leftOptions);\r\n    }\r\n    onStart() {\r\n        /**\r\n         * We need to query for the ion-item\r\n         * every time the gesture starts. Developers\r\n         * may toggle ion-item elements via *ngIf.\r\n         */\r\n        this.item = this.el.querySelector('ion-item');\r\n        const { contentEl } = this;\r\n        if (contentEl) {\r\n            this.initialContentScrollY = disableContentScrollY(contentEl);\r\n        }\r\n        openSlidingItem = this.el;\r\n        if (this.tmr !== undefined) {\r\n            clearTimeout(this.tmr);\r\n            this.tmr = undefined;\r\n        }\r\n        if (this.openAmount === 0) {\r\n            this.optsDirty = true;\r\n            this.state = 4 /* SlidingState.Enabled */;\r\n        }\r\n        this.initialOpenAmount = this.openAmount;\r\n        if (this.item) {\r\n            this.item.style.transition = 'none';\r\n        }\r\n    }\r\n    onMove(gesture) {\r\n        if (this.optsDirty) {\r\n            this.calculateOptsWidth();\r\n        }\r\n        let openAmount = this.initialOpenAmount - gesture.deltaX;\r\n        switch (this.sides) {\r\n            case 2 /* ItemSide.End */:\r\n                openAmount = Math.max(0, openAmount);\r\n                break;\r\n            case 1 /* ItemSide.Start */:\r\n                openAmount = Math.min(0, openAmount);\r\n                break;\r\n            case 3 /* ItemSide.Both */:\r\n                break;\r\n            case 0 /* ItemSide.None */:\r\n                return;\r\n            default:\r\n                console.warn('invalid ItemSideFlags value', this.sides);\r\n                break;\r\n        }\r\n        let optsWidth;\r\n        if (openAmount > this.optsWidthRightSide) {\r\n            optsWidth = this.optsWidthRightSide;\r\n            openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;\r\n        }\r\n        else if (openAmount < -this.optsWidthLeftSide) {\r\n            optsWidth = -this.optsWidthLeftSide;\r\n            openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;\r\n        }\r\n        this.setOpenAmount(openAmount, false);\r\n    }\r\n    onEnd(gesture) {\r\n        const { contentEl, initialContentScrollY } = this;\r\n        if (contentEl) {\r\n            resetContentScrollY(contentEl, initialContentScrollY);\r\n        }\r\n        const velocity = gesture.velocityX;\r\n        let restingPoint = this.openAmount > 0 ? this.optsWidthRightSide : -this.optsWidthLeftSide;\r\n        // Check if the drag didn't clear the buttons mid-point\r\n        // and we aren't moving fast enough to swipe open\r\n        const isResetDirection = this.openAmount > 0 === !(velocity < 0);\r\n        const isMovingFast = Math.abs(velocity) > 0.3;\r\n        const isOnCloseZone = Math.abs(this.openAmount) < Math.abs(restingPoint / 2);\r\n        if (swipeShouldReset(isResetDirection, isMovingFast, isOnCloseZone)) {\r\n            restingPoint = 0;\r\n        }\r\n        const state = this.state;\r\n        this.setOpenAmount(restingPoint, true);\r\n        if ((state & 32 /* SlidingState.SwipeEnd */) !== 0 && this.rightOptions) {\r\n            this.rightOptions.fireSwipeEvent();\r\n        }\r\n        else if ((state & 64 /* SlidingState.SwipeStart */) !== 0 && this.leftOptions) {\r\n            this.leftOptions.fireSwipeEvent();\r\n        }\r\n    }\r\n    calculateOptsWidth() {\r\n        this.optsWidthRightSide = 0;\r\n        if (this.rightOptions) {\r\n            this.rightOptions.style.display = 'flex';\r\n            this.optsWidthRightSide = this.rightOptions.offsetWidth;\r\n            this.rightOptions.style.display = '';\r\n        }\r\n        this.optsWidthLeftSide = 0;\r\n        if (this.leftOptions) {\r\n            this.leftOptions.style.display = 'flex';\r\n            this.optsWidthLeftSide = this.leftOptions.offsetWidth;\r\n            this.leftOptions.style.display = '';\r\n        }\r\n        this.optsDirty = false;\r\n    }\r\n    setOpenAmount(openAmount, isFinal) {\r\n        if (this.tmr !== undefined) {\r\n            clearTimeout(this.tmr);\r\n            this.tmr = undefined;\r\n        }\r\n        if (!this.item) {\r\n            return;\r\n        }\r\n        const { el } = this;\r\n        const style = this.item.style;\r\n        this.openAmount = openAmount;\r\n        if (isFinal) {\r\n            style.transition = '';\r\n        }\r\n        if (openAmount > 0) {\r\n            this.state =\r\n                openAmount >= this.optsWidthRightSide + SWIPE_MARGIN\r\n                    ? 8 /* SlidingState.End */ | 32 /* SlidingState.SwipeEnd */\r\n                    : 8 /* SlidingState.End */;\r\n        }\r\n        else if (openAmount < 0) {\r\n            this.state =\r\n                openAmount <= -this.optsWidthLeftSide - SWIPE_MARGIN\r\n                    ? 16 /* SlidingState.Start */ | 64 /* SlidingState.SwipeStart */\r\n                    : 16 /* SlidingState.Start */;\r\n        }\r\n        else {\r\n            /**\r\n             * The sliding options should not be\r\n             * clickable while the item is closing.\r\n             */\r\n            el.classList.add('item-sliding-closing');\r\n            /**\r\n             * Item sliding cannot be interrupted\r\n             * while closing the item. If it did,\r\n             * it would allow the item to get into an\r\n             * inconsistent state where multiple\r\n             * items are then open at the same time.\r\n             */\r\n            if (this.gesture) {\r\n                this.gesture.enable(false);\r\n            }\r\n            this.tmr = setTimeout(() => {\r\n                this.state = 2 /* SlidingState.Disabled */;\r\n                this.tmr = undefined;\r\n                if (this.gesture) {\r\n                    this.gesture.enable(!this.disabled);\r\n                }\r\n                el.classList.remove('item-sliding-closing');\r\n            }, 600);\r\n            openSlidingItem = undefined;\r\n            style.transform = '';\r\n            return;\r\n        }\r\n        style.transform = `translate3d(${-openAmount}px,0,0)`;\r\n        this.ionDrag.emit({\r\n            amount: openAmount,\r\n            ratio: this.getSlidingRatioSync(),\r\n        });\r\n    }\r\n    getSlidingRatioSync() {\r\n        if (this.openAmount > 0) {\r\n            return this.openAmount / this.optsWidthRightSide;\r\n        }\r\n        else if (this.openAmount < 0) {\r\n            return this.openAmount / this.optsWidthLeftSide;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n    render() {\r\n        const mode = getIonMode(this);\r\n        return (h(Host, { key: '83e1673fc5af892612deb9b49d5e792b8b0b6473', class: {\r\n                [mode]: true,\r\n                'item-sliding-active-slide': this.state !== 2 /* SlidingState.Disabled */,\r\n                'item-sliding-active-options-end': (this.state & 8 /* SlidingState.End */) !== 0,\r\n                'item-sliding-active-options-start': (this.state & 16 /* SlidingState.Start */) !== 0,\r\n                'item-sliding-active-swipe-end': (this.state & 32 /* SlidingState.SwipeEnd */) !== 0,\r\n                'item-sliding-active-swipe-start': (this.state & 64 /* SlidingState.SwipeStart */) !== 0,\r\n            } }));\r\n    }\r\n    get el() { return this; }\r\n    static get watchers() { return {\r\n        \"disabled\": [\"disabledChanged\"]\r\n    }; }\r\n    static get style() { return IonItemSlidingStyle0; }\r\n}, [0, \"ion-item-sliding\", {\r\n        \"disabled\": [4],\r\n        \"state\": [32],\r\n        \"getOpenAmount\": [64],\r\n        \"getSlidingRatio\": [64],\r\n        \"open\": [64],\r\n        \"close\": [64],\r\n        \"closeOpened\": [64]\r\n    }, undefined, {\r\n        \"disabled\": [\"disabledChanged\"]\r\n    }]);\r\nconst swipeShouldReset = (isResetDirection, isMovingFast, isOnResetZone) => {\r\n    // The logic required to know when the sliding item should close (openAmount=0)\r\n    // depends on three booleans (isResetDirection, isMovingFast, isOnResetZone)\r\n    // and it ended up being too complicated to be written manually without errors\r\n    // so the truth table is attached below: (0=false, 1=true)\r\n    // isResetDirection | isMovingFast | isOnResetZone || shouldClose\r\n    //         0        |       0      |       0       ||    0\r\n    //         0        |       0      |       1       ||    1\r\n    //         0        |       1      |       0       ||    0\r\n    //         0        |       1      |       1       ||    0\r\n    //         1        |       0      |       0       ||    0\r\n    //         1        |       0      |       1       ||    1\r\n    //         1        |       1      |       0       ||    1\r\n    //         1        |       1      |       1       ||    1\r\n    // The resulting expression was generated by resolving the K-map (Karnaugh map):\r\n    return (!isMovingFast && isOnResetZone) || (isResetDirection && isMovingFast);\r\n};\r\nfunction defineCustomElement$1() {\r\n    if (typeof customElements === \"undefined\") {\r\n        return;\r\n    }\r\n    const components = [\"ion-item-sliding\"];\r\n    components.forEach(tagName => { switch (tagName) {\r\n        case \"ion-item-sliding\":\r\n            if (!customElements.get(tagName)) {\r\n                customElements.define(tagName, ItemSliding);\r\n            }\r\n            break;\r\n    } });\r\n}\r\n\r\nconst IonItemSliding = ItemSliding;\r\nconst defineCustomElement = defineCustomElement$1;\r\n\r\nexport { IonItemSliding, defineCustomElement };\r\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,kBAAkB,EAAEC,WAAW,EAAEC,WAAW,EAAEC,CAAC,EAAEC,IAAI,QAAQ,+BAA+B;AACrG,SAASC,CAAC,IAAIC,qBAAqB,EAAEC,CAAC,IAAIC,qBAAqB,EAAEC,CAAC,IAAIC,mBAAmB,QAAQ,aAAa;AAC9G,SAASC,CAAC,IAAIC,SAAS,QAAQ,cAAc;AAC7C,SAASC,CAAC,IAAIC,eAAe,QAAQ,oBAAoB;AACzD,SAASC,CAAC,IAAIC,UAAU,QAAQ,mBAAmB;AAEnD,MAAMC,cAAc,GAAG,++DAA++D;AACtgE,MAAMC,oBAAoB,GAAGD,cAAc;AAE3C,MAAME,YAAY,GAAG,EAAE;AACvB,MAAMC,cAAc,GAAG,IAAI;AAC3B,IAAIC,eAAe;AACnB,MAAMC,WAAW,GAAG,aAActB,kBAAkB,CAAC,MAAMsB,WAAW,SAASrB,WAAW,CAAC;EACvFsB,WAAWA,CAAA,EAAG;IACV,KAAK,CAAC,CAAC;IACP,IAAI,CAACC,cAAc,CAAC,CAAC;IACrB,IAAI,CAACC,OAAO,GAAGvB,WAAW,CAAC,IAAI,EAAE,SAAS,EAAE,CAAC,CAAC;IAC9C,IAAI,CAACwB,IAAI,GAAG,IAAI;IAChB,IAAI,CAACC,UAAU,GAAG,CAAC;IACnB,IAAI,CAACC,iBAAiB,GAAG,CAAC;IAC1B,IAAI,CAACC,kBAAkB,GAAG,CAAC;IAC3B,IAAI,CAACC,iBAAiB,GAAG,CAAC;IAC1B,IAAI,CAACC,KAAK,GAAG,CAAC,CAAC;IACf,IAAI,CAACC,SAAS,GAAG,IAAI;IACrB,IAAI,CAACC,SAAS,GAAG,IAAI;IACrB,IAAI,CAACC,qBAAqB,GAAG,IAAI;IACjC,IAAI,CAACC,KAAK,GAAG,CAAC,CAAC;IACf,IAAI,CAACC,QAAQ,GAAG,KAAK;EACzB;EACAC,eAAeA,CAAA,EAAG;IACd,IAAI,IAAI,CAACC,OAAO,EAAE;MACd,IAAI,CAACA,OAAO,CAACC,MAAM,CAAC,CAAC,IAAI,CAACH,QAAQ,CAAC;IACvC;EACJ;EACA,MAAMI,iBAAiBA,CAAA,EAAG;IACtB,MAAM;MAAEC;IAAG,CAAC,GAAG,IAAI;IACnB,IAAI,CAACf,IAAI,GAAGe,EAAE,CAACC,aAAa,CAAC,UAAU,CAAC;IACxC,IAAI,CAACT,SAAS,GAAG3B,qBAAqB,CAACmC,EAAE,CAAC;IAC1C;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACE,gBAAgB,GAAG7B,eAAe,CAAC2B,EAAE,EAAE,iBAAiB,EAAE,YAAY;MACvE,MAAM,IAAI,CAACG,aAAa,CAAC,CAAC;IAC9B,CAAC,CAAC;IACF,MAAM,IAAI,CAACA,aAAa,CAAC,CAAC;IAC1B,IAAI,CAACN,OAAO,GAAG,CAAC,MAAM,MAAM,CAAC,aAAa,CAAC,EAAEO,aAAa,CAAC;MACvDJ,EAAE;MACFK,WAAW,EAAE,YAAY;MACzBC,eAAe,EAAE,GAAG;MACpBC,SAAS,EAAE,CAAC;MACZC,QAAQ,EAAGC,EAAE,IAAK,IAAI,CAACD,QAAQ,CAACC,EAAE,CAAC;MACnCC,OAAO,EAAEA,CAAA,KAAM,IAAI,CAACA,OAAO,CAAC,CAAC;MAC7BC,MAAM,EAAGF,EAAE,IAAK,IAAI,CAACE,MAAM,CAACF,EAAE,CAAC;MAC/BG,KAAK,EAAGH,EAAE,IAAK,IAAI,CAACG,KAAK,CAACH,EAAE;IAChC,CAAC,CAAC;IACF,IAAI,CAACb,eAAe,CAAC,CAAC;EAC1B;EACAiB,oBAAoBA,CAAA,EAAG;IACnB,IAAI,IAAI,CAAChB,OAAO,EAAE;MACd,IAAI,CAACA,OAAO,CAACiB,OAAO,CAAC,CAAC;MACtB,IAAI,CAACjB,OAAO,GAAGkB,SAAS;IAC5B;IACA,IAAI,CAAC9B,IAAI,GAAG,IAAI;IAChB,IAAI,CAAC+B,WAAW,GAAG,IAAI,CAACC,YAAY,GAAGF,SAAS;IAChD,IAAInC,eAAe,KAAK,IAAI,CAACoB,EAAE,EAAE;MAC7BpB,eAAe,GAAGmC,SAAS;IAC/B;IACA,IAAI,IAAI,CAACb,gBAAgB,EAAE;MACvB,IAAI,CAACA,gBAAgB,CAACgB,UAAU,CAAC,CAAC;MAClC,IAAI,CAAChB,gBAAgB,GAAGa,SAAS;IACrC;EACJ;EACA;AACJ;AACA;EACII,aAAaA,CAAA,EAAG;IACZ,OAAOC,OAAO,CAACC,OAAO,CAAC,IAAI,CAACnC,UAAU,CAAC;EAC3C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIoC,eAAeA,CAAA,EAAG;IACd,OAAOF,OAAO,CAACC,OAAO,CAAC,IAAI,CAACE,mBAAmB,CAAC,CAAC,CAAC;EACtD;EACA;AACJ;AACA;AACA;AACA;EACI,MAAMC,IAAIA,CAACC,IAAI,EAAE;IACb,IAAIC,EAAE;IACN;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,MAAMzC,IAAI,GAAI,IAAI,CAACA,IAAI,GAAG,CAACyC,EAAE,GAAG,IAAI,CAACzC,IAAI,MAAM,IAAI,IAAIyC,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,IAAI,CAAC1B,EAAE,CAACC,aAAa,CAAC,UAAU,CAAE;IAC9G,IAAIhB,IAAI,KAAK,IAAI,EAAE;MACf;IACJ;IACA,MAAM0C,aAAa,GAAG,IAAI,CAACC,UAAU,CAACH,IAAI,CAAC;IAC3C,IAAI,CAACE,aAAa,EAAE;MAChB;IACJ;IACA;AACR;AACA;AACA;IACQ,IAAIF,IAAI,KAAKV,SAAS,EAAE;MACpBU,IAAI,GAAGE,aAAa,KAAK,IAAI,CAACX,WAAW,GAAG,OAAO,GAAG,KAAK;IAC/D;IACA;IACAS,IAAI,GAAGtD,SAAS,CAACsD,IAAI,CAAC,GAAG,KAAK,GAAG,OAAO;IACxC,MAAMI,WAAW,GAAG,IAAI,CAAC3C,UAAU,GAAG,CAAC;IACvC,MAAM4C,SAAS,GAAG,IAAI,CAAC5C,UAAU,GAAG,CAAC;IACrC;AACR;AACA;AACA;IACQ,IAAI2C,WAAW,IAAIF,aAAa,KAAK,IAAI,CAACX,WAAW,EAAE;MACnD;IACJ;IACA,IAAIc,SAAS,IAAIH,aAAa,KAAK,IAAI,CAACV,YAAY,EAAE;MAClD;IACJ;IACA,IAAI,CAACc,WAAW,CAAC,CAAC;IAClB,IAAI,CAACrC,KAAK,GAAG,CAAC,CAAC;IACfsC,qBAAqB,CAAC,MAAM;MACxB,IAAI,CAACC,kBAAkB,CAAC,CAAC;MACzB,MAAMC,KAAK,GAAGT,IAAI,KAAK,KAAK,GAAG,IAAI,CAACrC,kBAAkB,GAAG,CAAC,IAAI,CAACC,iBAAiB;MAChFT,eAAe,GAAG,IAAI,CAACoB,EAAE;MACzB,IAAI,CAACmC,aAAa,CAACD,KAAK,EAAE,KAAK,CAAC;MAChC,IAAI,CAACxC,KAAK,GAAG+B,IAAI,KAAK,KAAK,GAAG,CAAC,CAAC,yBAAyB,EAAE,CAAC;IAChE,CAAC,CAAC;EACN;EACA;AACJ;AACA;EACI,MAAMW,KAAKA,CAAA,EAAG;IACV,IAAI,CAACD,aAAa,CAAC,CAAC,EAAE,IAAI,CAAC;EAC/B;EACA;AACJ;AACA;EACI,MAAMJ,WAAWA,CAAA,EAAG;IAChB,IAAInD,eAAe,KAAKmC,SAAS,EAAE;MAC/BnC,eAAe,CAACwD,KAAK,CAAC,CAAC;MACvBxD,eAAe,GAAGmC,SAAS;MAC3B,OAAO,IAAI;IACf;IACA,OAAO,KAAK;EAChB;EACA;AACJ;AACA;AACA;AACA;AACA;EACIa,UAAUA,CAACH,IAAI,EAAE;IACb,IAAIA,IAAI,KAAKV,SAAS,EAAE;MACpB,OAAO,IAAI,CAACC,WAAW,IAAI,IAAI,CAACC,YAAY;IAChD,CAAC,MACI,IAAIQ,IAAI,KAAK,OAAO,EAAE;MACvB,OAAO,IAAI,CAACT,WAAW;IAC3B,CAAC,MACI;MACD,OAAO,IAAI,CAACC,YAAY;IAC5B;EACJ;EACA,MAAMd,aAAaA,CAAA,EAAG;IAClB,MAAMkC,OAAO,GAAG,IAAI,CAACrC,EAAE,CAACsC,gBAAgB,CAAC,kBAAkB,CAAC;IAC5D,IAAIhD,KAAK,GAAG,CAAC;IACb;IACA,IAAI,CAAC0B,WAAW,GAAG,IAAI,CAACC,YAAY,GAAGF,SAAS;IAChD,KAAK,IAAIwB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,OAAO,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;MACrC,MAAMtD,IAAI,GAAGoD,OAAO,CAACpD,IAAI,CAACsD,CAAC,CAAC;MAC5B;AACZ;AACA;AACA;AACA;MACY;MACA,MAAME,MAAM,GAAGxD,IAAI,CAACyD,gBAAgB,KAAK3B,SAAS,GAAG,MAAM9B,IAAI,CAACyD,gBAAgB,CAAC,CAAC,GAAGzD,IAAI;MACzF,MAAMwC,IAAI,GAAGtD,SAAS,CAACsE,MAAM,CAAChB,IAAI,CAAC,GAAG,KAAK,GAAG,OAAO;MACrD,IAAIA,IAAI,KAAK,OAAO,EAAE;QAClB,IAAI,CAACT,WAAW,GAAGyB,MAAM;QACzBnD,KAAK,IAAI,CAAC,CAAC;MACf,CAAC,MACI;QACD,IAAI,CAAC2B,YAAY,GAAGwB,MAAM;QAC1BnD,KAAK,IAAI,CAAC,CAAC;MACf;IACJ;IACA,IAAI,CAACC,SAAS,GAAG,IAAI;IACrB,IAAI,CAACD,KAAK,GAAGA,KAAK;EACtB;EACAkB,QAAQA,CAACX,OAAO,EAAE;IACd;AACR;AACA;AACA;AACA;IACQ,MAAM8C,GAAG,GAAGC,QAAQ,CAACC,GAAG,KAAK,KAAK;IAClC,MAAMC,MAAM,GAAGH,GAAG,GAAGI,MAAM,CAACC,UAAU,GAAGnD,OAAO,CAACoD,MAAM,GAAG,EAAE,GAAGpD,OAAO,CAACoD,MAAM,GAAG,EAAE;IAClF,IAAIH,MAAM,EAAE;MACR,OAAO,KAAK;IAChB;IACA,MAAMI,QAAQ,GAAGtE,eAAe;IAChC,IAAIsE,QAAQ,IAAIA,QAAQ,KAAK,IAAI,CAAClD,EAAE,EAAE;MAClC,IAAI,CAAC+B,WAAW,CAAC,CAAC;IACtB;IACA,OAAO,CAAC,EAAE,IAAI,CAACd,YAAY,IAAI,IAAI,CAACD,WAAW,CAAC;EACpD;EACAN,OAAOA,CAAA,EAAG;IACN;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACzB,IAAI,GAAG,IAAI,CAACe,EAAE,CAACC,aAAa,CAAC,UAAU,CAAC;IAC7C,MAAM;MAAET;IAAU,CAAC,GAAG,IAAI;IAC1B,IAAIA,SAAS,EAAE;MACX,IAAI,CAACC,qBAAqB,GAAG1B,qBAAqB,CAACyB,SAAS,CAAC;IACjE;IACAZ,eAAe,GAAG,IAAI,CAACoB,EAAE;IACzB,IAAI,IAAI,CAACmD,GAAG,KAAKpC,SAAS,EAAE;MACxBqC,YAAY,CAAC,IAAI,CAACD,GAAG,CAAC;MACtB,IAAI,CAACA,GAAG,GAAGpC,SAAS;IACxB;IACA,IAAI,IAAI,CAAC7B,UAAU,KAAK,CAAC,EAAE;MACvB,IAAI,CAACK,SAAS,GAAG,IAAI;MACrB,IAAI,CAACG,KAAK,GAAG,CAAC,CAAC;IACnB;IACA,IAAI,CAACP,iBAAiB,GAAG,IAAI,CAACD,UAAU;IACxC,IAAI,IAAI,CAACD,IAAI,EAAE;MACX,IAAI,CAACA,IAAI,CAACoE,KAAK,CAACC,UAAU,GAAG,MAAM;IACvC;EACJ;EACA3C,MAAMA,CAACd,OAAO,EAAE;IACZ,IAAI,IAAI,CAACN,SAAS,EAAE;MAChB,IAAI,CAAC0C,kBAAkB,CAAC,CAAC;IAC7B;IACA,IAAI/C,UAAU,GAAG,IAAI,CAACC,iBAAiB,GAAGU,OAAO,CAAC0D,MAAM;IACxD,QAAQ,IAAI,CAACjE,KAAK;MACd,KAAK,CAAC,CAAC;QACHJ,UAAU,GAAGsE,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEvE,UAAU,CAAC;QACpC;MACJ,KAAK,CAAC,CAAC;QACHA,UAAU,GAAGsE,IAAI,CAACE,GAAG,CAAC,CAAC,EAAExE,UAAU,CAAC;QACpC;MACJ,KAAK,CAAC,CAAC;QACH;MACJ,KAAK,CAAC,CAAC;QACH;MACJ;QACIyE,OAAO,CAACC,IAAI,CAAC,6BAA6B,EAAE,IAAI,CAACtE,KAAK,CAAC;QACvD;IACR;IACA,IAAIuE,SAAS;IACb,IAAI3E,UAAU,GAAG,IAAI,CAACE,kBAAkB,EAAE;MACtCyE,SAAS,GAAG,IAAI,CAACzE,kBAAkB;MACnCF,UAAU,GAAG2E,SAAS,GAAG,CAAC3E,UAAU,GAAG2E,SAAS,IAAIlF,cAAc;IACtE,CAAC,MACI,IAAIO,UAAU,GAAG,CAAC,IAAI,CAACG,iBAAiB,EAAE;MAC3CwE,SAAS,GAAG,CAAC,IAAI,CAACxE,iBAAiB;MACnCH,UAAU,GAAG2E,SAAS,GAAG,CAAC3E,UAAU,GAAG2E,SAAS,IAAIlF,cAAc;IACtE;IACA,IAAI,CAACwD,aAAa,CAACjD,UAAU,EAAE,KAAK,CAAC;EACzC;EACA0B,KAAKA,CAACf,OAAO,EAAE;IACX,MAAM;MAAEL,SAAS;MAAEC;IAAsB,CAAC,GAAG,IAAI;IACjD,IAAID,SAAS,EAAE;MACXvB,mBAAmB,CAACuB,SAAS,EAAEC,qBAAqB,CAAC;IACzD;IACA,MAAMqE,QAAQ,GAAGjE,OAAO,CAACkE,SAAS;IAClC,IAAIC,YAAY,GAAG,IAAI,CAAC9E,UAAU,GAAG,CAAC,GAAG,IAAI,CAACE,kBAAkB,GAAG,CAAC,IAAI,CAACC,iBAAiB;IAC1F;IACA;IACA,MAAM4E,gBAAgB,GAAG,IAAI,CAAC/E,UAAU,GAAG,CAAC,KAAK,EAAE4E,QAAQ,GAAG,CAAC,CAAC;IAChE,MAAMI,YAAY,GAAGV,IAAI,CAACW,GAAG,CAACL,QAAQ,CAAC,GAAG,GAAG;IAC7C,MAAMM,aAAa,GAAGZ,IAAI,CAACW,GAAG,CAAC,IAAI,CAACjF,UAAU,CAAC,GAAGsE,IAAI,CAACW,GAAG,CAACH,YAAY,GAAG,CAAC,CAAC;IAC5E,IAAIK,gBAAgB,CAACJ,gBAAgB,EAAEC,YAAY,EAAEE,aAAa,CAAC,EAAE;MACjEJ,YAAY,GAAG,CAAC;IACpB;IACA,MAAMtE,KAAK,GAAG,IAAI,CAACA,KAAK;IACxB,IAAI,CAACyC,aAAa,CAAC6B,YAAY,EAAE,IAAI,CAAC;IACtC,IAAI,CAACtE,KAAK,GAAG,EAAE,CAAC,iCAAiC,CAAC,IAAI,IAAI,CAACuB,YAAY,EAAE;MACrE,IAAI,CAACA,YAAY,CAACqD,cAAc,CAAC,CAAC;IACtC,CAAC,MACI,IAAI,CAAC5E,KAAK,GAAG,EAAE,CAAC,mCAAmC,CAAC,IAAI,IAAI,CAACsB,WAAW,EAAE;MAC3E,IAAI,CAACA,WAAW,CAACsD,cAAc,CAAC,CAAC;IACrC;EACJ;EACArC,kBAAkBA,CAAA,EAAG;IACjB,IAAI,CAAC7C,kBAAkB,GAAG,CAAC;IAC3B,IAAI,IAAI,CAAC6B,YAAY,EAAE;MACnB,IAAI,CAACA,YAAY,CAACoC,KAAK,CAACkB,OAAO,GAAG,MAAM;MACxC,IAAI,CAACnF,kBAAkB,GAAG,IAAI,CAAC6B,YAAY,CAACuD,WAAW;MACvD,IAAI,CAACvD,YAAY,CAACoC,KAAK,CAACkB,OAAO,GAAG,EAAE;IACxC;IACA,IAAI,CAAClF,iBAAiB,GAAG,CAAC;IAC1B,IAAI,IAAI,CAAC2B,WAAW,EAAE;MAClB,IAAI,CAACA,WAAW,CAACqC,KAAK,CAACkB,OAAO,GAAG,MAAM;MACvC,IAAI,CAAClF,iBAAiB,GAAG,IAAI,CAAC2B,WAAW,CAACwD,WAAW;MACrD,IAAI,CAACxD,WAAW,CAACqC,KAAK,CAACkB,OAAO,GAAG,EAAE;IACvC;IACA,IAAI,CAAChF,SAAS,GAAG,KAAK;EAC1B;EACA4C,aAAaA,CAACjD,UAAU,EAAEuF,OAAO,EAAE;IAC/B,IAAI,IAAI,CAACtB,GAAG,KAAKpC,SAAS,EAAE;MACxBqC,YAAY,CAAC,IAAI,CAACD,GAAG,CAAC;MACtB,IAAI,CAACA,GAAG,GAAGpC,SAAS;IACxB;IACA,IAAI,CAAC,IAAI,CAAC9B,IAAI,EAAE;MACZ;IACJ;IACA,MAAM;MAAEe;IAAG,CAAC,GAAG,IAAI;IACnB,MAAMqD,KAAK,GAAG,IAAI,CAACpE,IAAI,CAACoE,KAAK;IAC7B,IAAI,CAACnE,UAAU,GAAGA,UAAU;IAC5B,IAAIuF,OAAO,EAAE;MACTpB,KAAK,CAACC,UAAU,GAAG,EAAE;IACzB;IACA,IAAIpE,UAAU,GAAG,CAAC,EAAE;MAChB,IAAI,CAACQ,KAAK,GACNR,UAAU,IAAI,IAAI,CAACE,kBAAkB,GAAGV,YAAY,GAC9C,CAAC,CAAC,yBAAyB,EAAE,CAAC,8BAC9B,CAAC,CAAC;IAChB,CAAC,MACI,IAAIQ,UAAU,GAAG,CAAC,EAAE;MACrB,IAAI,CAACQ,KAAK,GACNR,UAAU,IAAI,CAAC,IAAI,CAACG,iBAAiB,GAAGX,YAAY,GAC9C,EAAE,CAAC,2BAA2B,EAAE,CAAC,gCACjC,EAAE,CAAC;IACjB,CAAC,MACI;MACD;AACZ;AACA;AACA;MACYsB,EAAE,CAAC0E,SAAS,CAACC,GAAG,CAAC,sBAAsB,CAAC;MACxC;AACZ;AACA;AACA;AACA;AACA;AACA;MACY,IAAI,IAAI,CAAC9E,OAAO,EAAE;QACd,IAAI,CAACA,OAAO,CAACC,MAAM,CAAC,KAAK,CAAC;MAC9B;MACA,IAAI,CAACqD,GAAG,GAAGyB,UAAU,CAAC,MAAM;QACxB,IAAI,CAAClF,KAAK,GAAG,CAAC,CAAC;QACf,IAAI,CAACyD,GAAG,GAAGpC,SAAS;QACpB,IAAI,IAAI,CAAClB,OAAO,EAAE;UACd,IAAI,CAACA,OAAO,CAACC,MAAM,CAAC,CAAC,IAAI,CAACH,QAAQ,CAAC;QACvC;QACAK,EAAE,CAAC0E,SAAS,CAACG,MAAM,CAAC,sBAAsB,CAAC;MAC/C,CAAC,EAAE,GAAG,CAAC;MACPjG,eAAe,GAAGmC,SAAS;MAC3BsC,KAAK,CAACyB,SAAS,GAAG,EAAE;MACpB;IACJ;IACAzB,KAAK,CAACyB,SAAS,GAAI,eAAc,CAAC5F,UAAW,SAAQ;IACrD,IAAI,CAACF,OAAO,CAAC+F,IAAI,CAAC;MACdC,MAAM,EAAE9F,UAAU;MAClB+F,KAAK,EAAE,IAAI,CAAC1D,mBAAmB,CAAC;IACpC,CAAC,CAAC;EACN;EACAA,mBAAmBA,CAAA,EAAG;IAClB,IAAI,IAAI,CAACrC,UAAU,GAAG,CAAC,EAAE;MACrB,OAAO,IAAI,CAACA,UAAU,GAAG,IAAI,CAACE,kBAAkB;IACpD,CAAC,MACI,IAAI,IAAI,CAACF,UAAU,GAAG,CAAC,EAAE;MAC1B,OAAO,IAAI,CAACA,UAAU,GAAG,IAAI,CAACG,iBAAiB;IACnD,CAAC,MACI;MACD,OAAO,CAAC;IACZ;EACJ;EACA6F,MAAMA,CAAA,EAAG;IACL,MAAMC,IAAI,GAAG5G,UAAU,CAAC,IAAI,CAAC;IAC7B,OAAQb,CAAC,CAACC,IAAI,EAAE;MAAEyH,GAAG,EAAE,0CAA0C;MAAEC,KAAK,EAAE;QAClE,CAACF,IAAI,GAAG,IAAI;QACZ,2BAA2B,EAAE,IAAI,CAACzF,KAAK,KAAK,CAAC,CAAC;QAC9C,iCAAiC,EAAE,CAAC,IAAI,CAACA,KAAK,GAAG,CAAC,CAAC,4BAA4B,CAAC;QAChF,mCAAmC,EAAE,CAAC,IAAI,CAACA,KAAK,GAAG,EAAE,CAAC,8BAA8B,CAAC;QACrF,+BAA+B,EAAE,CAAC,IAAI,CAACA,KAAK,GAAG,EAAE,CAAC,iCAAiC,CAAC;QACpF,iCAAiC,EAAE,CAAC,IAAI,CAACA,KAAK,GAAG,EAAE,CAAC,mCAAmC;MAC3F;IAAE,CAAC,CAAC;EACZ;EACA,IAAIM,EAAEA,CAAA,EAAG;IAAE,OAAO,IAAI;EAAE;EACxB,WAAWsF,QAAQA,CAAA,EAAG;IAAE,OAAO;MAC3B,UAAU,EAAE,CAAC,iBAAiB;IAClC,CAAC;EAAE;EACH,WAAWjC,KAAKA,CAAA,EAAG;IAAE,OAAO5E,oBAAoB;EAAE;AACtD,CAAC,EAAE,CAAC,CAAC,EAAE,kBAAkB,EAAE;EACnB,UAAU,EAAE,CAAC,CAAC,CAAC;EACf,OAAO,EAAE,CAAC,EAAE,CAAC;EACb,eAAe,EAAE,CAAC,EAAE,CAAC;EACrB,iBAAiB,EAAE,CAAC,EAAE,CAAC;EACvB,MAAM,EAAE,CAAC,EAAE,CAAC;EACZ,OAAO,EAAE,CAAC,EAAE,CAAC;EACb,aAAa,EAAE,CAAC,EAAE;AACtB,CAAC,EAAEsC,SAAS,EAAE;EACV,UAAU,EAAE,CAAC,iBAAiB;AAClC,CAAC,CAAC,CAAC;AACP,MAAMsD,gBAAgB,GAAGA,CAACJ,gBAAgB,EAAEC,YAAY,EAAEqB,aAAa,KAAK;EACxE;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,OAAQ,CAACrB,YAAY,IAAIqB,aAAa,IAAMtB,gBAAgB,IAAIC,YAAa;AACjF,CAAC;AACD,SAASsB,qBAAqBA,CAAA,EAAG;EAC7B,IAAI,OAAOC,cAAc,KAAK,WAAW,EAAE;IACvC;EACJ;EACA,MAAMC,UAAU,GAAG,CAAC,kBAAkB,CAAC;EACvCA,UAAU,CAACC,OAAO,CAACC,OAAO,IAAI;IAAE,QAAQA,OAAO;MAC3C,KAAK,kBAAkB;QACnB,IAAI,CAACH,cAAc,CAACI,GAAG,CAACD,OAAO,CAAC,EAAE;UAC9BH,cAAc,CAACK,MAAM,CAACF,OAAO,EAAE/G,WAAW,CAAC;QAC/C;QACA;IACR;EAAE,CAAC,CAAC;AACR;AAEA,MAAMkH,cAAc,GAAGlH,WAAW;AAClC,MAAMmH,mBAAmB,GAAGR,qBAAqB;AAEjD,SAASO,cAAc,EAAEC,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}